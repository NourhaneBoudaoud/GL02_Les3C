{"version":3,"sources":["../src/program/index.ts","../src/argument/validate.ts","../src/error/base.ts","../src/error/action.ts","../src/logger/index.ts","../src/error/fatal.ts","../src/error/invalid-validator.ts","../src/error/missing-argument.ts","../src/error/missing-flag.ts","../src/error/multi-validation.ts","../src/utils/colorize.ts","../src/error/no-action.ts","../src/error/option-synopsis-syntax.ts","../src/option/utils.ts","../src/types.ts","../src/validator/utils.ts","../src/help/index.ts","../src/help/utils.ts","../src/help/templates/index.ts","../src/help/templates/command.ts","../src/help/templates/header.ts","../src/help/templates/program.ts","../src/help/templates/usage.ts","../src/help/templates/custom.ts","../src/autocomplete/index.ts","../src/parser/index.ts","../src/command/import.ts","../src/command/find.ts","../src/option/index.ts","../src/utils/suggest.ts","../src/utils/levenshtein.ts","../src/error/unknown-option.ts","../src/error/unknown-command.ts","../src/error/validation.ts","../src/error/too-many-arguments.ts","../src/validator/regexp.ts","../src/validator/array.ts","../src/validator/function.ts","../src/validator/caporal.ts","../src/validator/validate.ts","../src/argument/find.ts","../src/option/validate.ts","../src/option/find.ts","../src/command/validate-call.ts","../src/argument/synopsis.ts","../src/argument/index.ts","../src/option/mapping.ts","../src/config/index.ts","../src/command/index.ts","../src/command/scan.ts","../src/utils/fs.ts","../src/utils/version.ts","../src/index.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module caporal/program\n */\nimport { EventEmitter } from \"events\"\nimport fs from \"fs\"\nimport path from \"path\"\nimport kebabCase from \"lodash/kebabCase\"\nimport mapKeys from \"lodash/mapKeys\"\nimport { createCommand, HELP_CMD, PROG_CMD } from \"../command\"\nimport { Command } from \"../command\"\nimport { findCommand } from \"../command/find\"\nimport { scanCommands } from \"../command/scan\"\nimport { createConfigurator } from \"../config\"\nimport { fatalError, UnknownOrUnspecifiedCommandError } from \"../error\"\nimport { customizeHelp } from \"../help\"\nimport { CustomizedHelpOpts } from \"../help/types\"\nimport { getLogger, logger, setLogger } from \"../logger\"\nimport {\n  addGlobalOption,\n  createOption,\n  disableGlobalOption,\n  processGlobalOptions,\n  showHelp,\n} from \"../option\"\nimport { parseArgv } from \"../parser\"\nimport {\n  Action,\n  Logger,\n  Configurator,\n  ParserResult,\n  ParserTypes,\n  ProgramConfig,\n  CreateArgumentOpts,\n  CreateOptionProgramOpts,\n  CommandConfig,\n} from \"../types\"\nimport { CaporalValidator } from \"../types\"\nimport { detectVersion } from \"../utils/version\"\n\nconst LOG_LEVEL_ENV_VAR = \"CAPORAL_LOG_LEVEL\"\n// const SUPPORTED_SHELL = [\"bash\", \"zsh\", \"fish\"]\n\n/**\n * Program class\n *\n * @noInheritDoc\n */\nexport class Program extends EventEmitter {\n  private commands: Command[] = []\n  private _config: Configurator<ProgramConfig>\n  private _version?: string\n  private _name?: string\n  private _description?: string\n  private _programmaticMode = false\n  /**\n   * @internal\n   */\n  public defaultCommand?: Command\n  private _progCommand?: Command\n  private _bin: string\n  private _discoveryPath?: string\n  private _discoveredCommands?: Command[]\n\n  /**\n   * Number validator. Check that the value looks like a numeric one\n   * and cast the provided value to a javascript `Number`.\n   */\n  readonly NUMBER = CaporalValidator.NUMBER\n  /**\n   * String validator. Mainly used to make sure the value is a string,\n   * and prevent Caporal auto-casting of numerical values and boolean\n   * strings like `true` or `false`.\n   */\n  readonly STRING = CaporalValidator.STRING\n  /**\n   * Array validator. Convert any provided value to an array. If a string is provided,\n   * this validator will try to split it by commas.\n   */\n  readonly ARRAY = CaporalValidator.ARRAY\n  /**\n   * Boolean validator. Check that the value looks like a boolean.\n   * It accepts values like `true`, `false`, `yes`, `no`, `0`, and `1`\n   * and will auto-cast those values to `true` or `false`.\n   */\n  readonly BOOLEAN = CaporalValidator.BOOLEAN\n\n  /**\n   * Program constructor.\n   * - Detects the \"bin\" name from process argv\n   * - Detects the version from package.json\n   * - Set up the help command\n   * @ignore\n   */\n  constructor() {\n    super()\n    this._bin = path.basename(process.argv[1])\n    this._version = detectVersion()\n    this._config = createConfigurator({\n      strictArgsCount: true,\n      strictOptions: true,\n      autoCast: true,\n      logLevelEnvVar: LOG_LEVEL_ENV_VAR,\n    })\n    this.setupHelpCommand()\n    this.setupErrorHandlers()\n  }\n\n  /**\n   * @internal\n   */\n  private setupErrorHandlers(): void {\n    process.once(\"unhandledRejection\", (err) => {\n      if (this._programmaticMode) {\n        throw err\n      } else {\n        this.emit(\"error\", err)\n      }\n    })\n    this.on(\"error\", fatalError)\n  }\n\n  /**\n   * The program-command is the command attached directly to the program,\n   * meaning there is no command-keyword used to trigger it.\n   * Mainly used for programs executing only one possible action.\n   *\n   * @internal\n   */\n  get progCommand(): Command {\n    if (this._progCommand === undefined) {\n      this._progCommand = createCommand(this, PROG_CMD, \"\")\n    }\n    return this._progCommand\n  }\n\n  /**\n   * Setup the help command\n   */\n  private setupHelpCommand(): Command {\n    return this.command(HELP_CMD, \"Get help about a specific command\")\n      .argument(\n        \"[command]\",\n        \"Command name to get help for. If the command does not exist, global help will be displayed.\",\n      )\n      .action(async (actionParams) => {\n        const { args } = actionParams\n        const command = args.command\n          ? await findCommand(this, [args.command as string])\n          : undefined\n        // eslint-disable-next-line no-console\n        showHelp({ ...actionParams, command })\n        return -1\n      })\n      .hide()\n  }\n\n  /**\n   * Customize program help. Can be called multiple times to add more paragraphs and/or sections.\n   *\n   * @param text Help contents\n   * @param options Display options\n   */\n  help(text: string, options: Partial<CustomizedHelpOpts> = {}): Program {\n    customizeHelp(this, text, options)\n    return this\n  }\n\n  /**\n   * Toggle strict mode.\n   * Shortcut to calling: `.configure({ strictArgsCount: strict, strictOptions: strict })`.\n   * By default, the program is strict, so if you want to disable strict checking,\n   * just call `.strict(false)`. This setting can be overridden at the command level.\n   *\n   * @param strict boolean enabled flag\n   */\n  strict(strict = true): Program {\n    return this.configure({\n      strictArgsCount: strict,\n      strictOptions: strict,\n    })\n  }\n\n  /**\n   * Configure some behavioral properties.\n   *\n   * @param props properties to set/update\n   */\n  configure(props: Partial<ProgramConfig>): Program {\n    this._config.set(props)\n    return this\n  }\n\n  /**\n   * Get a configuration property value. {@link ProgramConfig Possible keys}.\n   *\n   * @param key Property\n   * @internal\n   */\n  getConfigProperty<K extends keyof ProgramConfig>(key: K): ProgramConfig[K] {\n    return this._config.get(key)\n  }\n\n  /**\n   * Return a reformatted synopsis string\n   *\n   * @internal\n   */\n  async getSynopsis(): Promise<string> {\n    return (\n      this.getBin() +\n      \" \" +\n      ((await this.hasCommands()) ? \"<command> \" : \"\") +\n      \"[ARGUMENTS...] [OPTIONS...]\"\n    ).trim()\n  }\n\n  /**\n   * Return the discovery path, if set\n   *\n   * @internal\n   */\n  get discoveryPath(): string | undefined {\n    return this._discoveryPath\n  }\n\n  /**\n   * Return the program version\n   *\n   * @internal\n   */\n  getVersion(): string | undefined {\n    return this._version\n  }\n\n  /**\n   * Set the version fo your program.\n   * You won't likely use this method as Caporal tries to guess it from your package.json\n   */\n  version(ver: string): Program {\n    this._version = ver\n    return this\n  }\n\n  /**\n   * Set the program name. If not set, the filename minus the extension will be used.\n   */\n  name(name: string): Program {\n    this._name = name\n    return this\n  }\n\n  /**\n   * Return the program name.\n   *\n   * @internal\n   */\n  getName(): string | undefined {\n    return this._name\n  }\n\n  /**\n   * Return the program description.\n   *\n   * @internal\n   */\n  getDescription(): string | undefined {\n    return this._description\n  }\n\n  /**\n   * Set the program description displayed in help.\n   */\n  description(desc: string): Program {\n    this._description = desc\n    return this\n  }\n\n  /**\n   * Get the bin name (the name of your executable).\n   *\n   * @internal\n   */\n  getBin(): string {\n    return this._bin\n  }\n\n  /**\n   * Sets the executable name. By default, it's auto-detected from the filename of your program.\n   *\n   * @param name Executable name\n   * @example\n   * ```ts\n   * program.bin('myprog')\n   * ```\n   */\n  bin(name: string): Program {\n    this._bin = name\n    return this\n  }\n\n  /**\n   * Set a custom logger for your program.\n   * Your logger should implement the {@link Logger} interface.\n   */\n  logger(logger: Logger): Program {\n    setLogger(logger)\n    return this\n  }\n\n  /**\n   * Get the configured logger instance\n   */\n  getLogger(): Logger {\n    return getLogger()\n  }\n\n  /**\n   * Disable a global option. Will warn if the global option\n   * does not exist of has already been disabled.\n   *\n   * @param name Name, short, or long notation of the option to disable.\n   */\n  disableGlobalOption(name: string): Program {\n    const disabled = disableGlobalOption(name)\n    if (!disabled) {\n      logger.warn(\n        \"Cannot disable global option %s. Either the global option does not exist or has already been disabled.\",\n      )\n    }\n    return this\n  }\n\n  /**\n   * Returns the list of all commands registered\n   * - By default, Caporal creates one: the \"help\" command\n   * - When calling argument() or action() on the program instance,\n   * Caporal also create what is called the \"program command\", which\n   * is a command directly attach to the program, usually used\n   * in mono-command programs.\n   * @internal\n   */\n  getCommands(): Command[] {\n    return this.commands\n  }\n\n  /**\n   * Add a command to the program.\n   *\n   * @param name Command name\n   * @param description Command description\n   * @example\n   * ```ts\n   * program.command('order', 'Order some food')\n   * ```\n   */\n  command(\n    name: string,\n    description: string,\n    config: Partial<CommandConfig> = {},\n  ): Command {\n    const cmd = createCommand(this, name, description, config)\n    this.commands.push(cmd)\n    return cmd\n  }\n\n  /**\n   * Check if the program has user-defined commands.\n   *\n   * @internal\n   * @private\n   */\n  async hasCommands(): Promise<boolean> {\n    return (await this.getAllCommands()).length > 1\n  }\n\n  /**\n   * @internal\n   */\n  async getAllCommands(): Promise<Command[]> {\n    const discoveredCommands = await this.scanCommands()\n    return [...this.commands, ...discoveredCommands]\n  }\n\n  /**\n   * Return the log level override, if any is provided using\n   * the right environment variable.\n   *\n   * @internal\n   * @private\n   */\n  public getLogLevelOverride(): string | undefined {\n    return process.env[this.getConfigProperty(\"logLevelEnvVar\")]\n  }\n\n  /**\n   * Enable or disable auto casting of arguments & options at the program level.\n   *\n   * @param enabled\n   */\n  cast(enabled: boolean): Program {\n    return this.configure({ autoCast: enabled })\n  }\n\n  /**\n   * Sets a *unique* action for the *entire* program.\n   *\n   * @param {Function} action - Action to run\n   */\n  action(action: Action): Program {\n    this.progCommand.action(action)\n    return this\n  }\n\n  /**\n   * Add an argument to the *unique* command of the program.\n   */\n  argument(\n    synopsis: string,\n    description: string,\n    options: CreateArgumentOpts = {},\n  ): Command {\n    return this.progCommand.argument(synopsis, description, options)\n  }\n\n  /**\n   * Add an option to the *unique* command of the program,\n   * or add a global option to the program when `options.global`\n   * is set to `true`.\n   *\n   * @param synopsis Option synopsis like '-f, --force', or '-f, --file \\<file\\>', or '--with-openssl [path]'\n   * @param description Option description\n   * @param options Additional parameters\n   */\n  option(\n    synopsis: string,\n    description: string,\n    options: CreateOptionProgramOpts = {},\n  ): Program {\n    if (options.global) {\n      const opt = createOption(synopsis, description, options)\n      addGlobalOption(opt, options.action)\n    } else {\n      this.progCommand.option(synopsis, description, options)\n    }\n    return this\n  }\n\n  /**\n   * Discover commands from a specified path.\n   *\n   * Commands must be organized into files (one command per file) in a file tree like:\n   *\n   * ```sh\n   * └── commands\n   *     ├── config\n   *     │   ├── set.ts\n   *     │   └── unset.ts\n   *     ├── create\n   *     │   ├── job.ts\n   *     │   └── service.ts\n   *     ├── create.ts\n   *     ├── describe.ts\n   *     └── get.ts\n   * ```\n   *\n   * The code above shows a short example of `kubectl` commands and subcommands.\n   * In this case, Caporal will generate the following commands:\n   *\n   * - kubectl get [args...] [options...]\n   * - kubectl config set [args...] [options...]\n   * - kubectl config unset [args...] [options...]\n   * - kubectl create [args...] [options...]\n   * - kubectl create job [args...] [options...]\n   * - kubectl create service [args...] [options...]\n   * - kubectl describe [args...] [options...]\n   * - kubectl get [args...] [options...]\n   *\n   * Notice how the `config` command has a mandatory subcommand associated,\n   * hence cannot be called without a subcommand, contrary to the `create` command.\n   * This is why there is no `config.ts` in the tree.\n   *\n   * @param path\n   */\n  discover(dirPath: string): Program {\n    let stat\n    try {\n      stat = fs.statSync(dirPath)\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n    if (!stat || !stat.isDirectory()) {\n      throw new Error(\n        \"Caporal setup error: parameter `dirPath` of discover() should be a directory\",\n      )\n    }\n\n    this._discoveryPath = dirPath\n    return this\n  }\n\n  /**\n   * Do a full scan of the discovery path to get all existing commands\n   * This should only be used to generate the full list of command,\n   * as for help rendering\n   *\n   * @private\n   */\n  private async scanCommands(): Promise<Command[]> {\n    if (this._discoveryPath === undefined) {\n      return []\n    }\n    if (this._discoveredCommands) {\n      return this._discoveredCommands\n    }\n    this._discoveredCommands = await scanCommands(this, this._discoveryPath)\n    return this._discoveredCommands\n  }\n\n  /* istanbul ignore next */\n  /**\n   * Reset all commands\n   *\n   * @internal\n   */\n  public reset(): Program {\n    this.commands = []\n    this._progCommand = undefined\n    this.setupHelpCommand()\n    return this\n  }\n\n  /**\n   * Run the program by parsing command line arguments.\n   * Caporal will automatically detect command line arguments from `process.argv` values,\n   * but it can be overridden by providing the `argv` parameter. It returns a Promise\n   * of the value returned by the *Action* triggered.\n   *\n   * ::: warning Be careful\n   * This method returns a `Promise`. You'll usually ignore the returned promise and call run() like this:\n   *\n   * ```ts\n   * [...]\n   * program.action(...)\n   * program.run()\n   * ```\n   *\n   * If you do add some `.catch()` handler to it, Caporal won't display any potential errors\n   * that the promise could reject, and will let you the responsibility to do it.\n   * :::\n   *\n   * @param argv Command line arguments to parse, default to `process.argv.slice(2)`.\n   */\n  async run(argv?: string[]): Promise<unknown> {\n    if (!argv) {\n      // used on web playground\n      if (process.env.CAPORAL_CMD_LINE) {\n        argv = process.env.CAPORAL_CMD_LINE.split(\" \").slice(1)\n        // defaut value for common usage\n      } else {\n        argv = process.argv.slice(2)\n      }\n    }\n\n    /*\n      Search for the command from args, then, if a default command exists,\n      take it, otherwise take the command attached to the program,\n      and lastly the help command/\n    */\n    const cmd = await this.findCommand(argv)\n\n    // parse command line args\n    const result = parseArgv(cmd?.getParserConfig(), argv)\n\n    /* \n      Run command with parsed args.\n      We are forced to catch a potential error to prevent the rejected\n      promise to propagate un in the stack. \n    */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    return this._run(result, cmd) /*\n    .catch((e) => e) */\n  }\n\n  /**\n   * Try to find the executed command from argv\n   * If command cannot be found from argv, return the default command if any,\n   * then the program-command if any, or finally `undefined`.\n   * If argv is empty, and there is no defaultCommand or progCommand\n   * use the help command\n   *\n   * @param argv\n   */\n  private async findCommand(argv: string[]): ReturnType<typeof findCommand> {\n    const cmd = await findCommand(this, argv)\n    if (cmd) {\n      return cmd\n    }\n    /**\n     * If we've been asked for help (and only help) and there is no progCommand,\n     * so we should return undefined in order for the help command to display\n     * the global help.\n     * Fixes this particular use case: Fixes this particular use case:\n     * https://github.com/mattallty/Caporal.js/issues/196\n     */\n    if (argv.every((arg) => arg === \"--help\") && !this._progCommand) {\n      return\n    }\n\n    return this.defaultCommand || this._progCommand\n  }\n\n  /**\n   * Run a command, providing parsed data\n   *\n   * @param result\n   * @param cmd\n   * @internal\n   */\n  private async _run(result: ParserResult, cmd?: Command): Promise<unknown> {\n    // Override logger level via ENV if needed\n    const loggerLevel = this.getLogLevelOverride()\n    if (loggerLevel && Object.keys(logger.levels).includes(loggerLevel)) {\n      logger.level = loggerLevel\n    }\n    // try to run the command\n    // try {\n    if (!cmd) {\n      // we may not have any associated command, but some global options may have been passed\n      // process them, if any\n      // Process any global options\n      const processedResult = { ...result, errors: [], args: {} }\n      const shouldStop = await processGlobalOptions(processedResult, this)\n      if (shouldStop) {\n        this.emit(\"run\")\n        return -1\n      }\n      // todo: use case: \"git unknown-command some args\" will display \"unknown command 'git'\"\n      // but should display \"unknown command 'git unknown-command'\"\n      throw new UnknownOrUnspecifiedCommandError(this, result.rawArgv[0])\n    }\n    const ret = await cmd.run(result)\n    this.emit(\"run\", ret)\n    return ret\n  }\n\n  /**\n   * Programmatic usage. Execute input command with given arguments & options\n   *\n   * Not ideal regarding type casting etc.\n   *\n   * @param args argv array\n   * @param options options object\n   * @param ddash double dash array\n   * @public\n   */\n  async exec(\n    args: string[],\n    options: Record<string, ParserTypes> = {},\n    ddash: string[] = [],\n  ): Promise<unknown> {\n    this._programmaticMode = true\n    const cmd = await this.findCommand(args)\n    options = mapKeys(options, (v, key) => kebabCase(key))\n    return this._run(\n      {\n        args,\n        options,\n        line: args.join(\" \"),\n        rawOptions: options,\n        rawArgv: args,\n        ddash,\n      },\n      cmd,\n    )\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport reduce from \"lodash/reduce\"\nimport {\n  TooManyArgumentsError,\n  MissingArgumentError,\n  BaseError,\n  CommonError,\n} from \"../error\"\nimport type {\n  Argument,\n  ArgumentsRange,\n  ParsedArguments,\n  ParsedArgumentsObject,\n  ParsedArgument,\n  Promisable,\n} from \"../types\"\n\nimport type { Command } from \"../command\"\nimport { validate } from \"../validator/validate\"\nimport { findArgument } from \"./find\"\n\n/**\n * Get the number of required argument for a given command\n *\n * @param cmd\n */\nexport function getRequiredArgsCount(cmd: Command): number {\n  return cmd.args.filter((a) => a.required).length\n}\n\nexport function getArgsObjectFromArray(\n  cmd: Command,\n  args: ParsedArguments,\n): ParsedArgumentsObject {\n  const result: ParsedArgumentsObject = {}\n  return cmd.args.reduce((acc, arg, index) => {\n    if (args[index] !== undefined) {\n      acc[arg.name] = args[index]\n    } else if (arg.default !== undefined) {\n      acc[arg.name] = arg.default\n    }\n    return acc\n  }, result)\n}\n\n/**\n * Check if the given command has at leat one variadic argument\n *\n * @param cmd\n */\nexport function hasVariadicArgument(cmd: Command): boolean {\n  return cmd.args.some((a) => a.variadic)\n}\n\nexport function getArgsRange(cmd: Command): ArgumentsRange {\n  const min = getRequiredArgsCount(cmd)\n  const max = hasVariadicArgument(cmd) ? Infinity : cmd.args.length\n  return { min, max }\n}\n\nexport function checkRequiredArgs(\n  cmd: Command,\n  args: ParsedArgumentsObject,\n  parsedArgv: ParsedArguments,\n): BaseError[] {\n  const errors = cmd.args.reduce((acc, arg) => {\n    if (args[arg.name] === undefined && arg.required) {\n      acc.push(new MissingArgumentError(arg, cmd))\n    }\n    return acc\n  }, [] as BaseError[])\n\n  // Check if there is more args than specified\n  if (cmd.strictArgsCount) {\n    const numArgsError = checkNumberOfArgs(cmd, parsedArgv)\n    if (numArgsError) {\n      errors.push(numArgsError)\n    }\n  }\n\n  return errors\n}\n\nfunction checkNumberOfArgs(\n  cmd: Command,\n  args: ParsedArguments,\n): TooManyArgumentsError | void {\n  const range = getArgsRange(cmd)\n  const argsCount = Object.keys(args).length\n  if (range.max !== Infinity && range.max < Object.keys(args).length) {\n    return new TooManyArgumentsError(cmd, range, argsCount)\n  }\n}\n\nexport function removeCommandFromArgs(\n  cmd: Command,\n  args: ParsedArguments,\n): ParsedArguments {\n  const words = cmd.name.split(\" \").length\n  return args.slice(words)\n}\n\nfunction validateArg(arg: Argument, value: ParsedArgument): ReturnType<typeof validate> {\n  return arg.validator ? validate(value, arg.validator, arg) : value\n}\n\ntype VariadicArgument = ParsedArgument\ntype ArgsValidatorAccumulator = Record<string, Promisable<VariadicArgument>>\n\ninterface ArgsValidationResult {\n  args: ParsedArgumentsObject\n  errors: CommonError[]\n}\n\n/**\n *\n * @param cmd\n * @param parsedArgv\n *\n * @todo Bugs:\n *\n *\n * ts-node examples/pizza/pizza.ts cancel my-order jhazd hazd\n *\n * -> result ok, should be too many arguments\n *\n */\nexport async function validateArgs(\n  cmd: Command,\n  parsedArgv: ParsedArguments,\n): Promise<ArgsValidationResult> {\n  // remove the command from the argv array\n  const formatedArgs = cmd.isProgramCommand()\n    ? parsedArgv\n    : removeCommandFromArgs(cmd, parsedArgv)\n\n  // transfrom args array to object, and set defaults for arguments not passed\n  const argsObj = getArgsObjectFromArray(cmd, formatedArgs)\n  const errors: CommonError[] = []\n\n  const validations = reduce(\n    argsObj,\n    (acc, value, key) => {\n      const arg = findArgument(cmd, key)\n      try {\n        /* istanbul ignore if -- should not happen */\n        if (!arg) {\n          throw new BaseError(`Unknown argumment ${key}`)\n        }\n        acc[key] = validateArg(arg, value)\n      } catch (e) {\n        errors.push(e)\n      }\n      return acc\n    },\n    {} as ArgsValidatorAccumulator,\n  )\n\n  const result = await reduce(\n    validations,\n    async (prevPromise, value, key): Promise<ParsedArgumentsObject> => {\n      const collection = await prevPromise\n      collection[key] = await value\n      return collection\n    },\n    Promise.resolve({}) as Promise<ParsedArgumentsObject>,\n  )\n\n  errors.push(...checkRequiredArgs(cmd, result, formatedArgs))\n\n  return { args: result, errors }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { ErrorMetadata } from \"../types\"\n\nexport type CommonError = Error | BaseError\n\nexport class BaseError extends Error {\n  public meta: ErrorMetadata\n\n  constructor(message: string, meta: ErrorMetadata = {}) {\n    super(message)\n    Object.setPrototypeOf(this, new.target.prototype)\n    this.name = this.constructor.name\n    this.meta = meta\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\n\nexport class ActionError extends BaseError {\n  constructor(error: string | Error) {\n    const message = typeof error === \"string\" ? error : error.message\n    super(message, { error })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport { createLogger as winstonCreateLogger, transports, format } from \"winston\"\nimport { inspect } from \"util\"\nimport { default as chalk, supportsColor } from \"chalk\"\nimport type { Logger } from \"../types\"\nimport replace from \"lodash/replace\"\nimport { EOL } from \"os\"\n\nconst caporalFormat = format.printf((data) => {\n  const { level, ...meta } = data\n  let { message } = data\n  let prefix = \"\"\n\n  const levelStr = getLevelString(level)\n  const metaStr = formatMeta(meta)\n\n  if (metaStr !== \"\") {\n    message += `${EOL}${levelStr}: ${metaStr}`\n  }\n\n  if (level === \"error\") {\n    const spaces = \" \".repeat(meta.paddingLeft || 7)\n    prefix = EOL\n    message = `${replace(message, new RegExp(EOL, \"g\"), EOL + spaces)}${EOL}`\n  }\n\n  return `${prefix}${levelStr}: ${message}`\n})\n\nfunction formatMeta(meta: Record<string, unknown>): string {\n  delete meta.message\n  delete meta[Symbol.for(\"level\") as unknown as string]\n  delete meta[Symbol.for(\"message\") as unknown as string]\n  delete meta[Symbol.for(\"splat\") as unknown as string]\n  if (Object.keys(meta).length) {\n    return inspect(meta, {\n      showHidden: false,\n      colors: logger.colorsEnabled,\n    })\n  }\n  return \"\"\n}\n\nfunction getLevelString(level: string): string {\n  if (!logger.colorsEnabled) {\n    return level\n  }\n  let levelStr = level\n  switch (level) {\n    case \"error\":\n      levelStr = chalk.bold.redBright(level)\n      break\n    case \"warn\":\n      levelStr = chalk.hex(\"#FF9900\")(level)\n      break\n    case \"info\":\n      levelStr = chalk.hex(\"#569cd6\")(level)\n      break\n    case \"debug\":\n    case \"silly\":\n      levelStr = chalk.dim(level)\n      break\n  }\n  return levelStr\n}\n\nexport let logger: Logger = createDefaultLogger()\n\nexport function setLogger(loggerObj: Logger): void {\n  logger = loggerObj\n}\n\nexport function getLogger(): Logger {\n  return logger\n}\n\nexport function createDefaultLogger(): Logger {\n  const logger = winstonCreateLogger({\n    transports: [\n      new transports.Console({\n        format: format.combine(format.splat(), caporalFormat),\n      }),\n    ],\n  }) as Logger\n  // disableColors() disable on the logger level,\n  // while chalk supports the --color/--no-color flag\n  // as well as the FORCE_COLOR env var\n  logger.disableColors = () => {\n    logger.transports[0].format = caporalFormat\n    logger.colorsEnabled = false\n  }\n  logger.colorsEnabled = supportsColor !== false\n  return logger\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { logger } from \"../logger\"\nimport type { BaseError } from \"./base\"\n\n/**\n * @param err - Error object\n */\nexport function fatalError(error: BaseError): void {\n  if (logger.level == \"debug\") {\n    logger.log({\n      level: \"error\",\n      ...error,\n      message: error.message + \"\\n\\n\" + error.stack,\n      stack: error.stack,\n      name: error.name,\n    })\n  } else {\n    logger.error(error.message)\n  }\n  process.exitCode = 1\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { Validator } from \"../types\"\nexport class InvalidValidatorError extends BaseError {\n  constructor(validator: Validator) {\n    super(\"Caporal setup error: Invalid flag validator setup.\", { validator })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { Command } from \"../command\"\nimport { Argument } from \"../types\"\nimport chalk from \"chalk\"\n\nexport class MissingArgumentError extends BaseError {\n  constructor(argument: Argument, command: Command) {\n    const msg = `Missing required argument ${chalk.bold(argument.name)}.`\n    super(msg, { argument, command })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { Command } from \"../command\"\nimport { Option } from \"../types\"\nimport chalk from \"chalk\"\n\nexport class MissingFlagError extends BaseError {\n  constructor(flag: Option, command: Command) {\n    const msg = `Missing required flag ${chalk.bold(flag.allNotations.join(\" | \"))}.`\n    super(msg, { flag, command })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError, CommonError } from \"./base\"\nimport chalk from \"chalk\"\nimport { colorize } from \"../utils/colorize\"\nimport type { Command } from \"../command\"\n\nexport class ValidationSummaryError extends BaseError {\n  constructor(cmd: Command, errors: CommonError[]) {\n    const plural = errors.length > 1 ? \"s\" : \"\"\n    const msg =\n      `The following error${plural} occured:\\n` +\n      errors.map((e) => \"- \" + e.message.replace(/\\n/g, \"\\n  \")).join(\"\\n\") +\n      \"\\n\\n\" +\n      chalk.dim(\"Synopsis: \") +\n      colorize(cmd.synopsis)\n    super(msg, { errors })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport c from \"chalk\"\n\nexport function colorize(text: string): string {\n  return text\n    .replace(/<([^>]+)>/gi, (match) => {\n      return c.hex(\"#569cd6\")(match)\n    })\n    .replace(/<command>/gi, (match) => {\n      return c.hex(\"#ff9900\")(match)\n    })\n    .replace(/\\[([^[\\]]+)\\]/gi, (match) => {\n      return c.hex(\"#aaa\")(match)\n    })\n    .replace(/ --?([^\\s,]+)/gi, (match) => {\n      return c.green(match)\n    })\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { Command } from \"../command\"\n\nexport class NoActionError extends BaseError {\n  constructor(cmd?: Command) {\n    let message\n    if (cmd && !cmd.isProgramCommand()) {\n      message = `Caporal Error: You haven't defined any action for command '${cmd.name}'.\\nUse .action() to do so.`\n    } else {\n      message = `Caporal Error: You haven't defined any action for program.\\nUse .action() to do so.`\n    }\n    super(message, { cmd })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\n\nexport class OptionSynopsisSyntaxError extends BaseError {\n  constructor(synopsis: string) {\n    super(`Syntax error in option synopsis: ${synopsis}`, { synopsis })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport camelCase from \"lodash/camelCase\"\nimport kebabCase from \"lodash/kebabCase\"\nimport { OptionSynopsisSyntaxError } from \"../error\"\nimport { OptionValueType } from \"../types\"\nimport type { OptionSynopsis, ParserTypes } from \"../types\"\n\nconst REG_SHORT_OPT = /^-[a-z]$/i\nconst REG_LONG_OPT = /^--[a-z]{2,}/i\nconst REG_OPT = /^(-[a-zA-Z]|--\\D{1}[\\w-]+)/\n\nfunction isShortOpt(flag: string): boolean {\n  return REG_SHORT_OPT.test(flag)\n}\n\nfunction isLongOpt(flag: string): boolean {\n  return REG_LONG_OPT.test(flag)\n}\n\n/**\n * Specific version of camelCase which does not lowercase short flags\n *\n * @param name Flag short or long name\n */\nfunction camelCaseOpt(name: string): string {\n  return name.length === 1 ? name : camelCase(name)\n}\n\nexport function getCleanNameFromNotation(str: string, camelCased = true): string {\n  str = str\n    .replace(/([[\\]<>]+)/g, \"\")\n    .replace(\"...\", \"\")\n    .replace(/^no-/, \"\")\n  return camelCased ? camelCaseOpt(str) : str\n}\n\nexport function getDashedOpt(name: string): string {\n  const l = Math.min(name.length, 2)\n  return \"-\".repeat(l) + kebabCase(name)\n}\n\nexport function isNumeric(n: string): boolean {\n  return !isNaN(parseFloat(n)) && isFinite(Number(n))\n}\n\nexport function isOptionStr(str?: string): str is string {\n  return str !== undefined && str !== \"--\" && REG_OPT.test(str)\n}\n\nexport function isConcatenatedOpt(str: string): string[] | false {\n  if (str.match(/^-([a-z]{2,})/i)) {\n    return str.substr(1).split(\"\")\n  }\n  return false\n}\n\nexport function isNegativeOpt(opt: string): boolean {\n  return opt.substr(0, 5) === \"--no-\"\n}\n\nexport function isOptArray(flag: ParserTypes | ParserTypes[]): flag is ParserTypes[] {\n  return Array.isArray(flag)\n}\n\nexport function formatOptName(name: string): string {\n  return camelCaseOpt(name.replace(/^--?(no-)?/, \"\"))\n}\n\n/**\n * Parse a option synopsis\n *\n * @example\n * parseSynopsis(\"-f, --file <path>\")\n * // Returns...\n * {\n *    longName: 'file',\n *    longNotation: '--file',\n *    shortNotation: '-f',\n *    shortName: 'f'\n *    valueType: 0, // 0 = optional, 1 = required, 2 = no value\n *    variadic: false\n *    name: 'file'\n *    notation: '--file' // either the long or short notation\n * }\n *\n * @param synopsis\n * @ignore\n */\nexport function parseOptionSynopsis(synopsis: string): OptionSynopsis {\n  // synopsis = synopsis.trim()\n  const analysis: OptionSynopsis = {\n    variadic: false,\n    valueType: OptionValueType.None,\n    valueRequired: false,\n    allNames: [],\n    allNotations: [],\n    name: \"\",\n    notation: \"\",\n    synopsis,\n  }\n\n  const infos: Partial<OptionSynopsis> = synopsis\n    .split(/[\\s\\t,]+/)\n    .reduce((acc, value) => {\n      if (isLongOpt(value)) {\n        acc.longNotation = value\n        acc.longName = getCleanNameFromNotation(value.substring(2))\n        acc.allNames.push(acc.longName)\n        acc.allNotations.push(value)\n      } else if (isShortOpt(value)) {\n        acc.shortNotation = value\n        acc.shortName = value.substring(1)\n        acc.allNames.push(acc.shortName)\n        acc.allNotations.push(value)\n      } else if (value.substring(0, 1) === \"[\") {\n        acc.valueType = OptionValueType.Optional\n        acc.valueRequired = false\n        acc.variadic = value.substr(-4, 3) === \"...\"\n      } else if (value.substring(0, 1) === \"<\") {\n        acc.valueType = OptionValueType.Required\n        acc.valueRequired = true\n        acc.variadic = value.substr(-4, 3) === \"...\"\n      }\n      return acc\n    }, analysis)\n\n  if (infos.longName === undefined && infos.shortName === undefined) {\n    throw new OptionSynopsisSyntaxError(synopsis)\n  }\n\n  infos.name = infos.longName || (infos.shortName as string)\n  infos.notation = infos.longNotation || (infos.shortNotation as string)\n\n  const fullSynopsis = { ...infos } as OptionSynopsis\n\n  return fullSynopsis\n}\n","/**\n * List of Caporal type aliases.\n *\n * @packageDocumentation\n * @module caporal/types\n */\n//\nimport { Logger as WinstonLogger } from \"winston\"\nimport { Program } from \"./program\"\nimport { Command } from \"./command\"\nimport { CommonError } from \"./error\"\n\n/**\n * The Caporal logger interface. It extends the [Winston](https://github.com/winstonjs/winston) Logger interface\n * and adds the following properties & methods.\n * @noInheritDoc\n */\nexport interface Logger extends WinstonLogger {\n  /**\n   * Allow to force disabling colors.\n   */\n  disableColors(): void\n  /**\n   * Tells Caporal if colors are enabled or not.\n   */\n  colorsEnabled: boolean\n}\n\nexport type GlobalOptions = Map<Option, Action | undefined>\n\n/**\n * Caporal-provided validator flags.\n */\nexport enum CaporalValidator {\n  /**\n   * Number validator. Check that the value looks like a numeric one\n   * and cast the provided value to a javascript `Number`.\n   */\n  NUMBER = 1,\n  /**\n   * Boolean validator. Check that the value looks like a boolean.\n   * It accepts values like `true`, `false`, `yes`, `no`, `0`, and `1`\n   * and will auto-cast those values to `true` or `false`.\n   */\n  BOOLEAN = 2,\n  /**\n   * String validator. Mainly used to make sure the value is a string,\n   * and prevent Caporal auto-casting of numerics values and boolean\n   * strings like `true` or `false`.\n   */\n  STRING = 4,\n  /**\n   * Array validator. Convert any provided value to an array. If a string is provided,\n   * this validator will try to split it by commas.\n   */\n  ARRAY = 8,\n}\n\ntype FunctionValidatorArgument = ParsedArgument | ParsedOption\n\n// export type FunctionValidator<T = FunctionValidatorArgument> = (\n//   value: T,\n// ) => FunctionValidatorArgument | Promise<FunctionValidatorArgument>\n\nexport interface FunctionValidator<T = FunctionValidatorArgument> {\n  (value: T): Promisable<T>\n}\n\n// export type FunctionValidator<T = FunctionValidatorArgument> = (value: T) => Promisable<T>\n\nexport type Validator = RegExp | FunctionValidator | CaporalValidator | ParserTypes[]\n\n/**\n * @internal\n */\nexport interface ValidatorWrapper {\n  validate(\n    value: ParsedArgument | ParsedOption,\n  ): ParserTypes | ParserTypes[] | Promise<ParserTypes>\n  getChoices(): ParserTypes[]\n}\n\nexport interface OptionSynopsis {\n  name: string\n  notation: string\n  shortName?: string\n  shortNotation?: string\n  longName?: string\n  longNotation?: string\n  allNames: string[]\n  allNotations: string[]\n  synopsis: string\n  valueRequired: boolean\n  valueType?: OptionValueType\n  variadic: boolean\n}\n\n/**\n * Option possible value.\n *\n */\nexport enum OptionValueType {\n  /**\n   * Value is optional.\n   */\n  Optional,\n  /**\n   * Value is required.\n   */\n  Required,\n  /**\n   * Option does not have any possible value\n   */\n  None,\n}\n\n/**\n * Option properties\n */\nexport interface CreateOptionCommandOpts {\n  /**\n   * Optional validator\n   */\n  validator?: Validator\n  /**\n   * Default value for the Option\n   */\n  default?: ParsedOption\n  /**\n   * Set the Option as itself required\n   */\n  required?: boolean\n  /**\n   * Hide the option from help\n   */\n  hidden?: boolean\n}\n\n/**\n * Option properties\n */\nexport interface CreateOptionProgramOpts extends CreateOptionCommandOpts {\n  /**\n   * Set to `true` for a global option.\n   */\n  global?: boolean\n  /**\n   * Action to call when a global-option is passed.\n   * Only available for global options, e.g. when `global` is set to `true`.\n   */\n  action?: Action\n}\n\nexport interface CreateArgumentOpts {\n  /**\n   * Argument validator.\n   */\n  validator?: Validator\n  /**\n   * Argument default value.\n   */\n  default?: ParsedArgument\n}\n\nexport interface ArgumentSynopsis {\n  /**\n   * Argument name.\n   */\n  readonly name: string\n  /**\n   * Boolean indicating if the argument is required.\n   */\n  readonly required: boolean\n  /**\n   * Synopsis string.\n   */\n  readonly synopsis: string\n  /**\n   * Boolean indicating if the argument is valiadic,\n   * e.g. can be repeated to contain an array of values.\n   */\n  readonly variadic: boolean\n}\n\nexport interface Argument extends ArgumentSynopsis {\n  readonly default?: ParsedArgument\n  readonly description: string\n  readonly choices: ParsedArgument[]\n  readonly validator?: Validator\n  typeHint?: string\n  kind: \"argument\"\n}\n\nexport interface Option extends OptionSynopsis {\n  readonly boolean: boolean\n  readonly default?: ParsedOption\n  readonly description: string\n  readonly choices: ParsedOption[]\n  readonly validator?: Validator\n  readonly required: boolean\n  readonly visible: boolean\n  typeHint?: string\n  kind: \"option\"\n}\n\n/**\n * A type that could be wrapped in a Promise, or not\n */\nexport type Promisable<T> = T | Promise<T>\n\n/**\n * Parameters object passed to an {@link Action} function\n */\nexport interface ActionParameters {\n  /**\n   * Parsed command line arguments\n   */\n  args: ParsedArgumentsObject\n  /**\n   * If the `dash` (double dash) config property is enabled,\n   * this *array* will contain all arguments present\n   * after '--'.\n   */\n  ddash: ParsedArguments\n  /**\n   * Parsed command line options\n   */\n  options: ParsedOptions\n  /**\n   * Program instance\n   */\n  program: Program\n  /**\n   * Contextual command, if any\n   */\n  command?: Command\n  /**\n   * Logger instance\n   */\n  logger: Logger\n}\n\n/**\n * An action is a function that will be executed upon a command call.\n */\nexport interface Action {\n  (params: ActionParameters): unknown\n}\n\nexport interface ErrorMetadata {\n  [meta: string]: unknown\n}\n\nexport type ParserTypes = string | number | boolean\n\n/**\n * Available options for the Caporal internal parser.\n * Arguments must be referenced by their position (0-based) and options by their name (short or long)\n * in {@link ParserOptions.boolean boolean}, {@link ParserOptions.string string}\n * and {@link ParserOptions.variadic variadic} parser options.\n *\n */\nexport interface ParserOptions {\n  /**\n   * List of {@link Argument Arguments} and {@link Options Options} to be casted as *booleans*.\n   * Arguments must be referenced by their position (0-based) and options by their name (short or long).\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { parseArgv } from \"caporal/parser\"\n   *\n   * parseArgv({\n   *  boolean: [2, 'sendEmail']\n   * })\n   *\n   * // ./my-cli-app first-arg second-arg 3rd-arg --sendEmail=1\n   * // -> \"3rd-arg\" will be casted to boolean as well as \"--sendEmail\"\n   * ```\n   */\n  boolean: (string | number)[]\n  /**\n   * List of {@link Argument Arguments} and {@link Options Options} to be casted as *strings*.\n   * Arguments must be referenced by their position (0-based) and options by their name (short or long).\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { parseArgv } from \"caporal/parser\"\n   *\n   * parseArgv({\n   *  string: [1]\n   * })\n   *\n   * // ./my-cli-app first-arg 2\n   * // -> second arg \"2\" will be casted to string instead of number\n   * ```\n   */\n  string: (string | number)[]\n  /**\n   * List of variadic {@link Argument Arguments} and {@link Options Options}, meaning\n   * that there value is an `Array`.\n   *\n   * Arguments must be referenced by their position (0-based) and options by their name (short or long).\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { parseArgv } from \"caporal/parser\"\n   *\n   * parseArgv({\n   *  variadic: [1]\n   * })\n   *\n   * // ./pizza order margherita regina --add sausages --add basil\n   * {\n   *   args: ['order', ['margherita', 'regina']]\n   *   options: {\n   *     add: ['sausages', 'basil']\n   *   }\n   * }\n   * ```\n   */\n  variadic: (string | number)[]\n  /**\n   * Double-dash (--) handling mode. If `true`, the parser will populate the\n   * {@link ParserResult.ddash} property, otherwise, arguments will be added\n   * to {@link ParserResult.args}.\n   */\n  ddash: boolean\n  /**\n   * Option aliases map.\n   */\n  alias: Record<string, string>\n  /**\n   * Enable or disable autocasting of arguments and options. Default to `true`.\n   */\n  autoCast: boolean\n}\n\nexport type ParsedArgument = ParserTypes | ParserTypes[]\nexport type ParsedArguments = ParsedArgument[]\nexport interface ParsedArgumentsObject {\n  [arg: string]: ParsedArgument\n}\n\nexport type ParsedOption = ParserTypes | ParserTypes[]\nexport interface ParsedOptions {\n  [opt: string]: ParsedOption\n}\n/**\n * @internal\n */\nexport interface ArgumentsRange {\n  min: number\n  max: number\n}\n\nexport interface ParserResult {\n  args: ParsedArguments\n  options: ParsedOptions\n  rawOptions: ParsedOptions\n  line: string\n  rawArgv: string[]\n  ddash: ParsedArguments\n}\n\nexport interface ParserProcessedResult extends Omit<ParserResult, \"args\"> {\n  args: ParsedArgumentsObject\n  errors: CommonError[]\n}\n\nexport interface CreateCommandParameters {\n  program: Program\n  createCommand(description?: string): Command\n}\nexport interface CommandCreator {\n  (options: CreateCommandParameters): Command\n}\n\n/**\n * Available configuration properties for the program.\n */\nexport type ProgramConfig = {\n  /**\n   * Strict checking of arguments count. If enabled, any additional argument willl trigger an error.\n   * Default to `true`.\n   */\n  strictArgsCount: boolean\n  /**\n   * Strict checking of options provided. If enabled, any unknown option will trigger an error.\n   * Default to `true`.\n   */\n  strictOptions: boolean\n  /**\n   * Auto-casting of arguments and options.\n   * Default to `true`.\n   */\n  autoCast: boolean\n  /**\n   * Environment variable to check for log level override.\n   * Default to \"CAPORAL_LOG_LEVEL\".\n   */\n  logLevelEnvVar: string\n}\nexport type CommandConfig = {\n  /**\n   * Strict checking of arguments count. If enabled, any additional argument willl trigger an error.\n   */\n  strictArgsCount?: boolean\n  /**\n   * Strict checking of options provided. If enabled, any unknown option will trigger an error.\n   */\n  strictOptions?: boolean\n  /**\n   * Auto-casting of arguments and options.\n   */\n  autoCast?: boolean\n  /**\n   * Visibility of the command in help.\n   */\n  visible: boolean\n}\n\nexport type BaseConfig = Record<string, boolean | string>\n\nexport interface Configurator<T extends BaseConfig> {\n  get<K extends keyof T>(key: K): T[K]\n  getAll(): T\n  set(props: Partial<T>): T\n  reset(): T\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { Validator } from \"../types\"\nimport { CaporalValidator, Argument, Option } from \"../types\"\nimport isNumber from \"lodash/isNumber\"\nimport { InvalidValidatorError } from \"../error\"\n\nexport function isCaporalValidator(\n  validator: Validator | undefined,\n): validator is number {\n  if (typeof validator !== \"number\") {\n    return false\n  }\n  const mask = getCaporalValidatorsMask()\n  const exist = (mask & validator) === validator\n  return exist\n}\n\nexport function isNumericValidator(validator: Validator | undefined): boolean {\n  return isCaporalValidator(validator) && Boolean(validator & CaporalValidator.NUMBER)\n}\n\nexport function isStringValidator(validator: Validator | undefined): boolean {\n  return isCaporalValidator(validator) && Boolean(validator & CaporalValidator.STRING)\n}\n\nexport function isBoolValidator(validator: Validator | undefined): boolean {\n  return isCaporalValidator(validator) && Boolean(validator & CaporalValidator.BOOLEAN)\n}\n\nexport function isArrayValidator(validator: Validator | undefined): boolean {\n  return isCaporalValidator(validator) && Boolean(validator & CaporalValidator.ARRAY)\n}\n\nfunction getCaporalValidatorsMask(): number {\n  return Object.values(CaporalValidator)\n    .filter(isNumber)\n    .reduce((a, b) => a | b, 0)\n}\n\nfunction checkCaporalValidator(validator: CaporalValidator): void {\n  if (!isCaporalValidator(validator)) {\n    throw new InvalidValidatorError(validator)\n  }\n}\n\nfunction checkUserDefinedValidator(validator: Validator): void {\n  if (\n    typeof validator !== \"function\" &&\n    !(validator instanceof RegExp) &&\n    !Array.isArray(validator)\n  ) {\n    throw new InvalidValidatorError(validator)\n  }\n}\n\nexport function checkValidator(validator: Validator | undefined): void {\n  if (validator !== undefined) {\n    typeof validator === \"number\"\n      ? checkCaporalValidator(validator)\n      : checkUserDefinedValidator(validator)\n  }\n}\n\nexport function getTypeHint(obj: Argument | Option): string | undefined {\n  let hint\n  if (\n    isBoolValidator(obj.validator) ||\n    (\"boolean\" in obj && obj.boolean && obj.default !== false)\n  ) {\n    hint = \"boolean\"\n  } else if (isNumericValidator(obj.validator)) {\n    hint = \"number\"\n  } else if (Array.isArray(obj.validator)) {\n    const stringified = JSON.stringify(obj.validator)\n    if (stringified.length < 300) {\n      hint = \"one of \" + stringified.substr(1, stringified.length - 2)\n    }\n  }\n  return hint\n}\n","/**\n * @packageDocumentation\n * @module caporal/help\n */\nimport { Command } from \"../command\"\nimport { Program } from \"../program\"\nimport replace from \"lodash/replace\"\nimport chalk from \"chalk\"\nimport { buildTable } from \"./utils\"\nimport { colorize } from \"../utils/colorize\"\nimport * as allTemplates from \"./templates\"\nimport { getGlobalOptions } from \"../option\"\nimport { CustomizedHelpMap, CustomizedHelpOpts, TemplateContext, Template } from \"./types\"\n\nconst templates = new Map(Object.entries(allTemplates))\nconst customHelpMap: CustomizedHelpMap = new Map()\n\n/**\n * Customize the help\n *\n * @param obj\n * @param text\n * @param options\n * @internal\n */\nexport function customizeHelp(\n  obj: Command | Program,\n  text: string,\n  options: Partial<CustomizedHelpOpts>,\n): void {\n  const opts: CustomizedHelpOpts = {\n    sectionName: \"\",\n    colorize: true,\n    ...options,\n  }\n  const data = customHelpMap.get(obj) || []\n  data.push({ text, options: opts })\n  customHelpMap.set(obj, data)\n}\n\n/**\n * Register a new help template\n *\n * @param name Template name\n * @param template Template function\n *\n */\nexport function registerTemplate(\n  name: string,\n  template: Template,\n): Map<string, Template> {\n  return templates.set(name, template)\n}\n\n/**\n * Helper to be used to call templates from within templates\n *\n * @param name Template name\n * @param ctx Execution context\n * @internal\n */\nexport async function tpl(name: string, ctx: TemplateContext): Promise<string> {\n  const template = templates.get(name)\n  if (!template) {\n    throw Error(`Caporal setup error: Unknown help template '${name}'`)\n  }\n  return template(ctx)\n}\n\n/**\n * @internal\n * @param program\n * @param command\n */\nexport function getContext(program: Program, command?: Command): TemplateContext {\n  const spaces = \" \".repeat(2)\n  const ctx: TemplateContext = {\n    prog: program,\n    cmd: command,\n    chalk: chalk,\n    colorize: colorize,\n    customHelp: customHelpMap,\n    tpl,\n    globalOptions: getGlobalOptions(),\n    table: buildTable,\n    spaces,\n    indent(str: string, sp = spaces) {\n      return sp + replace(str.trim(), /(\\r\\n|\\r|\\n)/g, \"\\n\" + sp)\n    },\n    eol: \"\\n\",\n    eol2: \"\\n\\n\",\n    eol3: \"\\n\\n\\n\",\n  }\n  return ctx\n}\n\n/**\n * Return the help text\n *\n * @param program Program instance\n * @param command Command instance, if any\n * @internal\n */\nexport async function getHelp(program: Program, command?: Command): Promise<string> {\n  const ctx = getContext(program, command)\n  return [await tpl(\"header\", ctx), await tpl(\"usage\", ctx)].join(\"\")\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport { table, getBorderCharacters } from \"table\"\nimport filter from \"lodash/filter\"\nimport type { TemplateContext } from \"./types\"\nimport type { Option, Argument } from \"../types\"\nimport type { Command } from \"../command\"\n\nexport function buildTable(data: string[][], options = {}): string {\n  return table(data, {\n    border: getBorderCharacters(`void`),\n    columnDefault: {\n      paddingLeft: 0,\n      paddingRight: 2,\n    },\n    columns: {\n      0: {\n        paddingLeft: 4,\n        width: 35,\n      },\n      1: {\n        width: 55,\n        wrapWord: true,\n        paddingRight: 0,\n      },\n    },\n    drawHorizontalLine: () => {\n      return false\n    },\n    ...options,\n  })\n}\n\nexport function getDefaultValueHint(obj: Argument | Option): string | undefined {\n  return obj.default !== undefined &&\n    !(\"boolean\" in obj && obj.boolean && obj.default === false)\n    ? \"default: \" + JSON.stringify(obj.default)\n    : undefined\n}\n\nfunction getOptionSynopsisHelp(\n  opt: Option,\n  { eol: crlf, chalk: c }: TemplateContext,\n): string {\n  return (\n    opt.synopsis +\n    (opt.required && opt.default === undefined ? crlf + c.dim(\"required\") : \"\")\n  )\n}\n\nexport function getOptionsTable(\n  options: Option[],\n  ctx: TemplateContext,\n  title = \"OPTIONS\",\n): string {\n  options = filter(options, \"visible\")\n  if (!options.length) {\n    return \"\"\n  }\n  const { chalk: c, eol: crlf, table, spaces } = ctx\n  const help = spaces + c.bold(title) + crlf + crlf\n  const rows = options.map((opt) => {\n    const def = getDefaultValueHint(opt)\n    const more = [opt.typeHint, def].filter((d) => d).join(\", \")\n    const syno = getOptionSynopsisHelp(opt, ctx)\n    const desc = opt.description + (more.length ? crlf + c.dim(more) : \"\")\n    return [syno, desc]\n  })\n  return help + table(rows)\n}\n\nexport function getArgumentsTable(\n  args: Argument[],\n  ctx: TemplateContext,\n  title = \"ARGUMENTS\",\n): string {\n  if (!args.length) {\n    return \"\"\n  }\n  const { chalk: c, eol, eol2, table, spaces } = ctx\n  const help = spaces + c.bold(title) + eol2\n  const rows = args.map((a) => {\n    const def = getDefaultValueHint(a)\n    const more = [a.typeHint, def].filter((d) => d).join(\", \")\n    const desc = a.description + (more.length ? eol + c.dim(more) : \"\")\n    return [a.synopsis, desc]\n  })\n  return help + table(rows)\n}\n\nexport function getCommandsTable(\n  commands: Command[],\n  ctx: TemplateContext,\n  title = \"COMMANDS\",\n): string {\n  const { chalk, prog, eol2, table, spaces } = ctx\n  const cmdHint = `Type '${prog.getBin()} help <command>' to get some help about a command`\n  const help =\n    spaces + chalk.bold(title) + ` ${chalk.dim(\"\\u2014\")} ` + chalk.dim(cmdHint) + eol2\n  const rows = commands\n    .filter((c) => c.visible)\n    .map((cmd) => {\n      return [chalk.hex(\"#ff9900\")(cmd.name), cmd.description || \"\"]\n    })\n\n  return help + table(rows)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nexport * from \"./command\"\nexport * from \"./header\"\nexport * from \"./program\"\nexport * from \"./usage\"\nexport * from \"./custom\"\n","/**\n * @packageDocumentation\n * @internal\n */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport type { TemplateContext, Template } from \"../types\"\nimport { getOptionsTable, getArgumentsTable } from \"../utils\"\nimport sortBy from \"lodash/sortBy\"\n\nexport const command: Template = async (ctx: TemplateContext) => {\n  const { cmd, globalOptions: globalFlags, eol, eol3, colorize, tpl } = ctx\n\n  const options = sortBy(cmd!.options, \"name\"),\n    globalOptions = Array.from(globalFlags.keys())\n\n  const help =\n    cmd!.synopsis +\n    eol3 +\n    (await tpl(\"custom\", ctx)) +\n    getArgumentsTable(cmd!.args, ctx) +\n    eol +\n    getOptionsTable(options, ctx) +\n    eol +\n    getOptionsTable(globalOptions, ctx, \"GLOBAL OPTIONS\")\n\n  return colorize(help)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { TemplateContext, Template } from \"../types\"\n\nexport const header: Template = (ctx: TemplateContext) => {\n  const { prog, chalk: c, spaces, eol, eol2 } = ctx\n  const version = process.env?.NODE_ENV === \"test\" ? \"\" : prog.getVersion()\n  return (\n    eol +\n    spaces +\n    (prog.getName() || prog.getBin()) +\n    \" \" +\n    (version || \"\") +\n    (prog.getDescription() ? \" \\u2014 \" + c.dim(prog.getDescription()) : \"\") +\n    eol2\n  )\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { TemplateContext, Template } from \"../types\"\nimport { getOptionsTable, getCommandsTable } from \"../utils\"\n\nexport const program: Template = async (ctx: TemplateContext) => {\n  const { prog, globalOptions, eol, eol3, colorize, tpl } = ctx\n  const commands = await prog.getAllCommands()\n  const options = Array.from(globalOptions.keys())\n  const help =\n    (await prog.getSynopsis()) +\n    eol3 +\n    (await tpl(\"custom\", ctx)) +\n    getCommandsTable(commands, ctx) +\n    eol +\n    getOptionsTable(options, ctx, \"GLOBAL OPTIONS\")\n\n  return colorize(help)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { TemplateContext, Template } from \"../types\"\n\nexport const usage: Template = async (ctx: TemplateContext) => {\n  const { tpl, prog, chalk: c, spaces, eol } = ctx\n  let { cmd } = ctx\n\n  // if help is asked without a `cmd` and that no command exists\n  // within the program, override `cmd` with the program-command\n  if (!cmd && !(await prog.hasCommands())) {\n    ctx.cmd = cmd = prog.progCommand\n  }\n\n  // usage\n  const usage = `${spaces + c.bold(\"USAGE\")} ${cmd?.name ? \"— \" + c.dim(cmd.name) : \"\"}\n  ${eol + spaces + spaces + c.dim(\"\\u25B8\")} `\n\n  const next = cmd ? await tpl(\"command\", ctx) : await tpl(\"program\", ctx)\n\n  return usage + next\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { TemplateContext, Template } from \"../types\"\n\nexport const custom: Template = (ctx: TemplateContext) => {\n  const { prog, cmd, eol2, eol3, chalk, colorize, customHelp, indent } = ctx\n  const data = customHelp.get(cmd || prog)\n  if (data) {\n    const txt = data\n      .map(({ text, options }) => {\n        let str = \"\"\n        if (options.sectionName) {\n          str += chalk.bold(options.sectionName) + eol2\n        }\n        const subtxt = options.colorize ? colorize(text) : text\n        str += options.sectionName ? indent(subtxt) : subtxt\n        return str + eol3\n      })\n      .join(\"\")\n    return indent(txt) + eol3\n  }\n  return \"\"\n}\n","/**\n * @packageDocumentation\n * @module caporal/autocomplete\n */\nimport tabtab from \"tabtab\"\nimport { parseArgv } from \"../parser\"\nimport { Program } from \"../program\"\nimport { removeCommandFromArgs } from \"../argument/validate\"\nimport { Argument, Option } from \"../types\"\nimport { Command } from \"../command\"\nimport { isOptionObject } from \"../option\"\nimport { findCommand } from \"../command/find\"\nimport filter from \"lodash/filter\"\nimport flatMap from \"lodash/flatMap\"\n\nimport { Completions, Completer, CompletionItem, CompletionContext } from \"./types\"\n\nconst completions: Completions = new Map()\n\n/**\n * Register a completion handler\n *\n * @param {Argument|Option} arg_or_opt argument or option to complete\n * @param {Function} completer\n */\nexport function registerCompletion(\n  argOrOpt: Argument | Option,\n  completer: Completer,\n): void {\n  completions.set(argOrOpt, completer)\n}\n\nexport async function installCompletion(program: Program): Promise<void> {\n  return tabtab.install({\n    name: program.getBin(),\n    completer: program.getBin(),\n  })\n}\n\nexport async function uninstallCompletion(program: Program): Promise<void> {\n  return tabtab.uninstall({\n    name: program.getBin(),\n  })\n}\n\n/**\n * Called by tabtab\n */\nexport async function complete(\n  program: Program,\n  { env, argv } = { env: process.env, argv: process.argv },\n): Promise<CompletionItem[] | false> {\n  const compEnv = tabtab.parseEnv(env)\n  if (!compEnv.complete) {\n    return false\n  }\n\n  const ctx = await getContext(program, compEnv, argv)\n  const compPromises = [\n    getCompCommands(ctx),\n    getCompArgValues(ctx),\n    getCompOptNames(ctx),\n    getCompOptValues(ctx),\n  ]\n\n  const comps = flatMap(await Promise.all(compPromises))\n  tabtab.log(comps)\n\n  return comps\n}\n\nasync function getContext(\n  program: Program,\n  compEnv: tabtab.TabtabEnv,\n  argv: string[],\n): Promise<CompletionContext> {\n  const { lastPartial } = compEnv\n  argv = argv.slice(4)\n  const currentCmd = await findCommand(program, argv)\n  const parserResult = parseArgv(currentCmd?.getParserConfig(), argv)\n  const lastPartIsOpt = lastPartial.startsWith(\"-\")\n  const lastPartIsKnownOpt = Boolean(\n    lastPartIsOpt && currentCmd && getLastPartIsKnownOpt(currentCmd, lastPartial),\n  )\n  const currentOpt = currentCmd\n    ? currentCmd.options.find((o) => o.allNames.includes(lastPartial))\n    : undefined\n\n  const ctx = {\n    program,\n    currentCmd,\n    compEnv,\n    parserResult,\n    lastPartIsOpt,\n    lastPartIsKnownOpt,\n    currentOpt,\n  }\n  return ctx\n}\n\nasync function getCompCommands(ctx: CompletionContext): Promise<CompletionItem[]> {\n  const {\n    compEnv: { line },\n    program,\n    currentCmd,\n  } = ctx\n  const commandMatch = (cmd: Command, str: string): boolean => {\n    return cmd.name.startsWith(str) || cmd.getAliases().some((a) => a.startsWith(str))\n  }\n  let commands = await program.getAllCommands()\n  commands = filter(commands, (cmd) => commandMatch(cmd, line) && cmd !== currentCmd)\n  return commands.map((cmd) => ({\n    name: cmd.name,\n    description: cmd.description,\n  }))\n}\n\nasync function getCompOptNames(ctx: CompletionContext): Promise<CompletionItem[]> {\n  const {\n    compEnv: { lastPartial },\n    currentCmd,\n  } = ctx\n\n  if (!currentCmd) {\n    return []\n  }\n\n  const matchOptionName = (o: Option): boolean => {\n    return Boolean(\n      (o.shortNotation != lastPartial && o.shortNotation?.startsWith(lastPartial)) ||\n        (o.longNotation != lastPartial && o.longNotation?.startsWith(lastPartial)),\n    )\n  }\n\n  return filter(currentCmd.options, matchOptionName).map((opt) => ({\n    name: opt.notation,\n    description: opt.description,\n  }))\n}\n\nasync function getCompOptValues(ctx: CompletionContext): Promise<CompletionItem[]> {\n  const { currentOpt } = ctx\n  if (!currentOpt) {\n    return []\n  }\n  // Choices\n  if (currentOpt.choices.length) {\n    return currentOpt.choices.map((choice) => ({\n      name: choice.toString(),\n      description: \"Value for option \" + currentOpt.synopsis,\n    }))\n  }\n\n  // Promise completion\n  const completer = completions.get(currentOpt)\n  if (completer) {\n    return hanldleCompleter(ctx, completer, currentOpt)\n  }\n\n  return []\n}\n\nasync function getCompArgValues(ctx: CompletionContext): Promise<CompletionItem[]> {\n  const {\n    compEnv: { lastPartial },\n    parserResult: { args },\n    currentCmd,\n    lastPartIsOpt,\n  } = ctx\n\n  if (!currentCmd || lastPartIsOpt) {\n    return []\n  }\n\n  const formatedArgs = currentCmd.isProgramCommand()\n    ? args\n    : removeCommandFromArgs(currentCmd, args)\n\n  const argsCount = formatedArgs.length\n  const arg = currentCmd.args[argsCount]\n\n  if (!arg) {\n    return []\n  }\n\n  // Choices\n  if (arg.choices.length) {\n    return arg.choices\n      .map((choice) => ({\n        name: choice.toString(),\n        description: \"Value for argument \" + arg.synopsis,\n      }))\n      .filter((choice) => !lastPartial || choice.name.toString().startsWith(lastPartial))\n  }\n\n  // Promise completion\n  const completion = completions.get(arg)\n  if (completion) {\n    return hanldleCompleter(ctx, completion, arg)\n  }\n\n  return []\n}\n\nasync function hanldleCompleter(\n  ctx: CompletionContext,\n  completer: Completer,\n  argOrOpt: Argument | Option,\n): Promise<CompletionItem[]> {\n  const type = isOptionObject(argOrOpt) ? \"option\" : \"argument\"\n  const res = await completer(ctx)\n  return res.map((item) => {\n    if (typeof item === \"object\") {\n      return item\n    }\n    return {\n      name: \"\" + item,\n      description: `Value for ${type} ${argOrOpt.synopsis}`,\n    }\n  })\n}\n\nfunction getLastPartIsKnownOpt(cmd: Command, lastPartial: string): boolean {\n  return cmd.options.some((o) => o.allNames.includes(lastPartial))\n}\n","/**\n * @packageDocumentation\n * @module parser\n */\nimport invert from \"lodash/invert\"\nimport findIndex from \"lodash/findIndex\"\nimport type {\n  ParserOptions,\n  ParserResult,\n  ParserTypes,\n  ParsedOptions,\n  ParsedArguments,\n} from \"../types\"\nimport {\n  isNumeric,\n  isConcatenatedOpt,\n  isNegativeOpt,\n  isOptionStr,\n  formatOptName,\n  isOptArray,\n} from \"../option/utils\"\n\nconst DDASH = \"--\"\n\nfunction isDdash(str?: string): str is string {\n  return str === DDASH\n}\n\nfunction castAsBool(value: string | boolean): boolean {\n  if (typeof value === \"boolean\") {\n    return value\n  }\n  return /^true|1|yes|on$/.test(value)\n}\n\nfunction castAsString(val: string | boolean): string {\n  return val + \"\"\n}\n\nfunction autoCast(val: string): ParserTypes {\n  // auto-casting \"true\" & \"false\"\n  if (/^true|false$/.test(val)) {\n    return val === \"true\"\n  }\n  // auto-casting numbers\n  return isNumeric(val) ? parseFloat(val) : val\n}\n\nfunction cast(name: string, val: string | true, options: ParserOptions): ParserTypes {\n  const cleanName = formatOptName(name)\n\n  // Force casting to string\n  if (options.string.includes(cleanName)) {\n    return castAsString(val)\n  }\n\n  // Force casting to bool\n  if (options.boolean.includes(cleanName) || typeof val === \"boolean\") {\n    return castAsBool(val)\n  }\n\n  return options.autoCast ? autoCast(val) : val\n}\n\n/**\n * Parse a line\n *\n * @param line Line to be parsed\n * @param options Parser options\n * @internal\n */\nexport function parseLine(\n  line: string,\n  options: Partial<ParserOptions> = {},\n): ParserResult {\n  return parseArgv(options, line.split(\" \"))\n}\n/**\n *\n * @param args Return the next option position unless there is some ddash before\n */\nfunction getNextOptPosition(args: string[]): number {\n  const ddash = args.indexOf(\"--\")\n  const opt = findIndex(args, isOptionStr)\n  return ddash < opt && ddash !== -1 ? -1 : opt\n}\n\nclass Tree {\n  cursor: number\n  private ddashHandled = false\n\n  constructor(private argv: string[]) {\n    this.cursor = 0\n  }\n\n  /* istanbul ignore next */\n  toJSON(): {\n    cursor: number\n    ddashHandled: boolean\n    argv: string[]\n    current?: string\n  } {\n    return {\n      cursor: this.cursor,\n      ddashHandled: this.ddashHandled,\n      current: this.current,\n      argv: this.argv,\n    }\n  }\n\n  markDdashHandled(): Tree {\n    this.ddashHandled = true\n    return this\n  }\n\n  hasDdashHandled(): boolean {\n    return this.ddashHandled\n  }\n\n  next(): string | undefined {\n    return this.argv[this.cursor + 1]\n  }\n\n  slice(start?: number, end?: number): string[] {\n    return this.argv.slice(start, end)\n  }\n\n  sliceFromHere(end?: number): string[] {\n    return this.slice(this.cursor, end)\n  }\n\n  forward(by = 1): true {\n    if (by === -1) {\n      return this.end()\n    }\n    this.cursor += by\n    return true\n  }\n\n  end(): true {\n    this.cursor = this.length\n    return true\n  }\n\n  get current(): string | undefined {\n    return this.argv[this.cursor]\n  }\n\n  get length(): number {\n    return this.argv.length\n  }\n}\n\nclass ArgumentParser {\n  public readonly args: ParsedArguments = []\n  public readonly ddash: ParsedArguments = []\n  public readonly rawArgv: string[]\n  public readonly line: string\n  private variadicId?: number\n  private key: \"args\" | \"ddash\" = \"args\"\n\n  constructor(\n    private config: ParserOptions,\n    argv: string[],\n  ) {\n    this.line = argv.join(\" \")\n    this.rawArgv = argv\n  }\n\n  toJSON(): {\n    args: ParsedArguments\n    ddash: ParsedArguments\n    rawArgv: string[]\n    line: string\n  } {\n    return {\n      args: this.args,\n      ddash: this.ddash,\n      rawArgv: this.rawArgv,\n      line: this.line,\n    }\n  }\n\n  inVariadicContext(): boolean | undefined {\n    const argsLen = this[this.key].length\n    if (this.config.variadic.includes(argsLen)) {\n      this.variadicId = argsLen\n    }\n    if (this.variadicId !== undefined) {\n      return true\n    }\n  }\n\n  markDdashHandled(tree: Tree): true {\n    if (this.config.ddash) {\n      // if ddash enabled, update the key\n      this.key = \"ddash\"\n    }\n    return tree.markDdashHandled().forward()\n  }\n\n  push(...values: string[]): true {\n    this[this.key].push(...values.map(this.config.autoCast ? autoCast : String))\n    return true\n  }\n\n  pushVariadic(tree: Tree): true {\n    const args = tree.sliceFromHere()\n    const until = getNextOptPosition(args)\n    this.variadicId = this.variadicId || 0\n    const variadic = (this[this.key][this.variadicId] =\n      (this[this.key][this.variadicId] as ParserTypes[]) || [])\n\n    variadic.push(\n      ...args\n        .slice(0, until === -1 ? undefined : until)\n        .filter((s: string) => !isDdash(s))\n        .map(this.config.autoCast ? autoCast : String),\n    )\n\n    return tree.forward(until)\n  }\n\n  visit(tree: Tree): unknown {\n    if (!tree.current || (isOptionStr(tree.current) && !tree.hasDdashHandled())) {\n      return false\n    }\n    if (isDdash(tree.current)) {\n      return this.markDdashHandled(tree)\n    } else if (!this.inVariadicContext()) {\n      this.push(tree.current)\n      return tree.forward()\n    }\n    return this.pushVariadic(tree)\n  }\n}\n\nclass OptionParser {\n  public readonly options: ParsedOptions = {}\n  public readonly rawOptions: ParsedOptions = {}\n\n  constructor(private config: ParserOptions) {}\n\n  toJSON(): {\n    options: ParsedOptions\n    rawOptions: ParsedOptions\n  } {\n    return {\n      options: this.options,\n      rawOptions: this.rawOptions,\n    }\n  }\n\n  handleOptWithoutValue(name: string, tree: Tree): void {\n    const next = tree.next()\n    const nextIsOptOrUndef = isOptionStr(next) || isDdash(next) || next === undefined\n    this.compute(\n      name,\n      cast(name, nextIsOptOrUndef ? true : (next as string), this.config),\n    )\n    if (!nextIsOptOrUndef) {\n      tree.forward()\n    }\n  }\n\n  handleConcatenatedOpts(tree: Tree, names: string[], val?: ParserTypes): void {\n    if (val === undefined) {\n      val = true\n      const next = tree.next()\n      const last = names[names.length - 1]\n      const alias = this.config.alias[last]\n      const shouldTakeNextAsVal =\n        next && !isOptionStr(next) && !isDdash(next) && !this.isBoolean(last, alias)\n      if (shouldTakeNextAsVal) {\n        tree.forward()\n        val = next as string\n      }\n    }\n    this.computeMulti(names, val)\n  }\n\n  visit(tree: Tree): boolean {\n    // only handle options\n    /* istanbul ignore if */\n    if (!tree.current || !isOptionStr(tree.current) || tree.hasDdashHandled()) {\n      // this is never reached because the scan stops if\n      // a visior returns true, and as the Argument visitor is the first in the\n      // list, arguments objects never reach the Options visitor\n      // keeping it here in case we change the order of visitors\n      return false\n    }\n\n    const [name, rawval] = tree.current.split(\"=\", 2)\n    const concatOpts = isConcatenatedOpt(name)\n\n    if (concatOpts) {\n      this.handleConcatenatedOpts(tree, concatOpts, rawval)\n    } else if (rawval) {\n      this.compute(name, cast(name, rawval, this.config))\n    } else {\n      this.handleOptWithoutValue(name, tree)\n    }\n\n    return tree.forward()\n  }\n\n  compute(name: string, val: ParserTypes): void {\n    const no = isNegativeOpt(name)\n    const cleanName = formatOptName(name)\n    const alias = this.config.alias[cleanName]\n\n    if (this.isVariadic(cleanName, alias)) {\n      const prop = this.options[cleanName]\n      this.rawOptions[name] = this.options[cleanName] = (\n        isOptArray(prop) ? prop : [prop]\n      ).concat(val)\n    } else {\n      this.rawOptions[name] = this.options[cleanName] = no ? !val : val\n    }\n    if (alias) {\n      this.options[alias] = this.options[cleanName]\n    }\n  }\n\n  // todo: handle variadic, even for compute multi\n  // TIP: (maybe just split and redirect the last char to compute())\n  computeMulti(multi: string[], val: ParserTypes): void {\n    const n = multi.length\n    multi.forEach((o, index) => {\n      const alias = this.config.alias[o]\n      this.options[o] = index + 1 === n ? cast(o, val as string, this.config) : true\n      this.rawOptions[\"-\" + o] = this.options[o]\n      if (alias) {\n        this.options[alias] = this.options[o]\n      }\n    })\n  }\n\n  isVariadic(name: string, alias: string): boolean {\n    return (\n      name in this.options &&\n      (this.config.variadic.includes(name) || this.config.variadic.includes(alias))\n    )\n  }\n\n  isBoolean(name: string, alias: string): boolean {\n    return this.config.boolean.includes(name) || this.config.boolean.includes(alias)\n  }\n}\n\n/**\n * Parse command line arguments\n *\n * @param options Parser options\n * @param argv command line arguments array (a.k.a. \"argv\")\n */\nexport function parseArgv(\n  options: Partial<ParserOptions> = {},\n  argv: string[] = process.argv.slice(2),\n): ParserResult {\n  const parseOpts: ParserOptions = {\n    autoCast: true,\n    ddash: false,\n    alias: {},\n    boolean: [],\n    string: [],\n    variadic: [],\n    ...options,\n  }\n  parseOpts.alias = { ...parseOpts.alias, ...invert(parseOpts.alias) }\n\n  const tree = new Tree(argv)\n  const flagParser = new OptionParser(parseOpts)\n  const argParser = new ArgumentParser(parseOpts, argv)\n  const visitors = [argParser, flagParser]\n\n  while (tree.current) {\n    visitors.some((v) => v.visit(tree))\n  }\n\n  return { ...flagParser.toJSON(), ...argParser.toJSON() }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport { CommandCreator } from \"../types\"\nimport path from \"path\"\n\nexport async function importCommand(file: string): Promise<CommandCreator> {\n  const { dir, name } = path.parse(file)\n  const filename = path.join(dir, name)\n  const mod = await import(filename)\n  return mod.default ?? mod\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { Program } from \"../program\"\nimport type { Command } from \".\"\nimport { importCommand } from \"./import\"\nimport { createCommand } from \".\"\nimport path from \"path\"\n\nexport async function findCommand(\n  program: Program,\n  argv: string[],\n): Promise<Command | undefined> {\n  const commands = program.getCommands()\n  const findRegisteredCommand = (search: string): Command | undefined =>\n    commands.find((c) => c.name === search || c.hasAlias(search))\n\n  let foundCommand\n  let i\n  for (i = 0; i < argv.length; i++) {\n    const cmd = argv.slice(0, i + 1).join(\" \")\n    // break as soon as possible\n    if (argv[i].startsWith(\"-\")) {\n      break\n    }\n    const potentialCmd =\n      findRegisteredCommand(cmd) || (await discoverCommand(program, cmd))\n    foundCommand = potentialCmd || foundCommand\n  }\n\n  return foundCommand\n}\n\n/**\n * Search for a command in discovery path\n */\nasync function discoverCommand(\n  program: Program,\n  cmd: string,\n): Promise<Command | undefined> {\n  if (program.discoveryPath === undefined) {\n    return\n  }\n  const filename = cmd.split(\" \").join(\"/\")\n  try {\n    const fullPath = path.join(program.discoveryPath, filename)\n    const cmdBuilder = await importCommand(fullPath)\n    const options = {\n      createCommand: createCommand.bind(null, program, cmd),\n      program,\n    }\n    return cmdBuilder(options)\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n}\n","/**\n * @packageDocumentation\n * @module caporal/option\n */\n\nimport {\n  Option,\n  OptionValueType,\n  CreateOptionProgramOpts,\n  CreateOptionCommandOpts,\n  Action,\n  ActionParameters,\n  GlobalOptions,\n  ParserProcessedResult,\n} from \"../types\"\nimport { checkValidator, isBoolValidator, getTypeHint } from \"../validator/utils\"\nimport { parseOptionSynopsis } from \"./utils\"\nimport { logger } from \"../logger\"\nimport type { Command } from \"../command\"\nimport type { Program } from \"../program\"\nimport { getHelp } from \"../help\"\nimport { installCompletion, uninstallCompletion } from \"../autocomplete\"\n\n/**\n * Create an Option object\n *\n * @internal\n * @param synopsis\n * @param description\n * @param options\n */\nexport function createOption(\n  synopsis: string,\n  description: string,\n  options: CreateOptionProgramOpts | CreateOptionCommandOpts = {},\n): Option {\n  // eslint-disable-next-line prefer-const\n  let { validator, required, hidden } = options\n\n  // force casting\n  required = Boolean(required)\n\n  checkValidator(validator)\n  const syno = parseOptionSynopsis(synopsis)\n  let boolean = syno.valueType === OptionValueType.None || isBoolValidator(validator)\n  if (validator && !isBoolValidator(validator)) {\n    boolean = false\n  }\n\n  const opt: Option = {\n    kind: \"option\",\n    default: boolean == true ? Boolean(options.default) : options.default,\n    description,\n    choices: Array.isArray(validator) ? validator : [],\n    ...syno,\n    required,\n    visible: !hidden,\n    boolean,\n    validator,\n  }\n\n  opt.typeHint = getTypeHint(opt)\n\n  return opt\n}\n\nexport { showHelp }\n\n/**\n * Display help. Return false to prevent further processing.\n *\n * @internal\n */\nconst showHelp: Action = async ({ program, command }: ActionParameters) => {\n    const help = await getHelp(program, command)\n    // eslint-disable-next-line no-console\n    console.log(help)\n    program.emit(\"help\", help)\n    return false\n  },\n  /**\n   * Display program version. Return false to prevent further processing.\n   *\n   * @internal\n   */\n  showVersion: Action = ({ program }: ActionParameters) => {\n    // eslint-disable-next-line no-console\n    console.log(program.getVersion())\n    program.emit(\"version\", program.getVersion())\n    return false\n  },\n  /**\n   * Disable colors in output\n   *\n   * @internal\n   */\n  disableColors: Action = ({ logger }: ActionParameters) => {\n    logger.disableColors()\n  },\n  /**\n   * Set verbosity to the maximum\n   *\n   * @internal\n   */\n  setVerbose: Action = ({ logger }: ActionParameters) => {\n    logger.level = \"silly\"\n  },\n  /**\n   * Makes the program quiet, eg displaying logs with level >= warning\n   */\n  setQuiet: Action = ({ logger }: ActionParameters) => {\n    logger.level = \"warn\"\n  },\n  /**\n   * Makes the program totally silent\n   */\n  setSilent: Action = ({ logger }: ActionParameters) => {\n    logger.silent = true\n  },\n  /**\n   * Install completion\n   */\n  installComp: Action = ({ program }: ActionParameters) => {\n    return installCompletion(program)\n  },\n  /**\n   * Uninstall completion\n   */\n  uninstallComp: Action = ({ program }: ActionParameters) => {\n    return uninstallCompletion(program)\n  }\n\n/**\n * Global options container\n *\n * @internal\n */\nlet globalOptions: undefined | GlobalOptions\n\n/**\n * Get the list of registered global flags\n *\n * @internal\n */\nexport function getGlobalOptions(): GlobalOptions {\n  if (globalOptions === undefined) {\n    globalOptions = setupGlobalOptions()\n  }\n  return globalOptions\n}\n\n/**\n * Set up the global flags\n *\n * @internal\n */\nfunction setupGlobalOptions(): GlobalOptions {\n  const help = createOption(\"-h, --help\", \"Display global help or command-related help.\"),\n    verbose = createOption(\n      \"-v, --verbose\",\n      \"Verbose mode: will also output debug messages.\",\n    ),\n    quiet = createOption(\n      \"--quiet\",\n      \"Quiet mode - only displays warn and error messages.\",\n    ),\n    silent = createOption(\n      \"--silent\",\n      \"Silent mode: does not output anything, giving no indication of success or failure other than the exit code.\",\n    ),\n    version = createOption(\"-V, --version\", \"Display version.\"),\n    color = createOption(\"--no-color\", \"Disable use of colors in output.\"),\n    installCompOpt = createOption(\n      \"--install-completion\",\n      \"Install completion for your shell.\",\n      { hidden: true },\n    ),\n    uninstallCompOpt = createOption(\n      \"--uninstall-completion\",\n      \"Uninstall completion for your shell.\",\n      { hidden: true },\n    )\n\n  return new Map([\n    [help, showHelp],\n    [version, showVersion],\n    [color, disableColors],\n    [verbose, setVerbose],\n    [quiet, setQuiet],\n    [silent, setSilent],\n    [installCompOpt, installComp],\n    [uninstallCompOpt, uninstallComp],\n  ])\n}\n\nexport function resetGlobalOptions(): GlobalOptions {\n  return (globalOptions = setupGlobalOptions())\n}\n\n/**\n * Disable a global option\n *\n * @param name Can be the option short/long name or notation\n */\nexport function disableGlobalOption(name: string): boolean {\n  const opts = getGlobalOptions()\n  for (const [opt] of opts) {\n    if (opt.allNames.includes(name) || opt.allNotations.includes(name)) {\n      return opts.delete(opt)\n    }\n  }\n  return false\n}\n\n/**\n * Add a global option to the program.\n * A global option is available at the program level,\n * and associated with one given {@link Action}.\n *\n * @param a {@link Option} instance, for example created using {@link createOption()}\n */\nexport function addGlobalOption(opt: Option, action?: Action): GlobalOptions {\n  return getGlobalOptions().set(opt, action)\n}\n\n/**\n * Process global options, if any\n * @internal\n */\nexport async function processGlobalOptions(\n  parsed: ParserProcessedResult,\n  program: Program,\n  command?: Command,\n): Promise<boolean> {\n  const { options } = parsed\n  const actionsParams = { ...parsed, logger, program, command }\n  const promises = Object.entries(options).map(([opt]) => {\n    const action = findGlobalOptAction(opt)\n    if (action) {\n      return action(actionsParams)\n    }\n  })\n  const results = await Promise.all(promises)\n  return results.some((r) => r === false)\n}\n\n/**\n * Find a global Option action from the option name (short or long)\n *\n * @param name Short or long name\n * @internal\n */\nexport function findGlobalOptAction(name: string): Action | undefined {\n  for (const [opt, action] of getGlobalOptions()) {\n    if (opt.allNames.includes(name)) {\n      return action\n    }\n  }\n}\n\n/**\n * Find a global Option by it's name (short or long)\n *\n * @param name Short or long name\n * @internal\n */\nexport function findGlobalOption(name: string): Option | undefined {\n  for (const [opt] of getGlobalOptions()) {\n    if (opt.allNames.includes(name)) {\n      return opt\n    }\n  }\n}\n\nexport function isOptionObject(obj: unknown): obj is Option {\n  return typeof obj == \"object\" && obj !== null && (obj as Option).kind == \"option\"\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport chalk from \"chalk\"\nimport { levenshtein } from \"./levenshtein\"\n\ninterface Suggestion {\n  distance: number\n  suggestion: string\n}\n\nconst MAX_DISTANCE = 2\n\nconst sortByDistance = (a: Suggestion, b: Suggestion): number => a.distance - b.distance\n\nconst keepMeaningfulSuggestions = (s: Suggestion): boolean => s.distance <= MAX_DISTANCE\n\nconst possibilitesMapper = (input: string, p: string): Suggestion => {\n  return { suggestion: p, distance: levenshtein(input, p) }\n}\n\n/**\n * Get autocomplete suggestions\n *\n * @param {String} input - User input\n * @param {String[]} possibilities - Possibilities to retrieve suggestions from\n */\nexport function getSuggestions(input: string, possibilities: string[]): string[] {\n  return possibilities\n    .map((p) => possibilitesMapper(input, p))\n    .filter(keepMeaningfulSuggestions)\n    .sort(sortByDistance)\n    .map((p) => p.suggestion)\n}\n\n/**\n * Make diff bolder in a string\n *\n * @param from original string\n * @param to target string\n */\nexport function boldDiffString(from: string, to: string): string {\n  return [...to]\n    .map((char, index) => {\n      if (char != from.charAt(index)) {\n        return chalk.bold.greenBright(char)\n      }\n      return char\n    })\n    .join(\"\")\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nexport function levenshtein(a: string, b: string): number {\n  if (a === b) {\n    return 0\n  }\n  if (!a.length || !b.length) {\n    return a.length || b.length\n  }\n  let cell = 0\n  let lcell = 0\n  let dcell = 0\n  const row = [...Array(b.length + 1).keys()]\n  for (let i = 0; i < a.length; i++) {\n    dcell = i\n    lcell = i + 1\n    for (let j = 0; j < b.length; j++) {\n      cell = a[i] === b[j] ? dcell : Math.min(...[dcell, row[j + 1], lcell]) + 1\n      dcell = row[j + 1]\n      row[j] = lcell\n      lcell = cell\n    }\n    row[row.length - 1] = cell\n  }\n  return cell\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport type { Option } from \"../types\"\nimport { getDashedOpt } from \"../option/utils\"\nimport { getGlobalOptions } from \"../option\"\nimport { getSuggestions, boldDiffString } from \"../utils/suggest\"\nimport c from \"chalk\"\nimport type { Command } from \"../command\"\nimport filter from \"lodash/fp/filter\"\nimport map from \"lodash/fp/map\"\n\n/**\n * @todo Rewrite\n */\nexport class UnknownOptionError extends BaseError {\n  constructor(flag: string, command: Command) {\n    const longFlags = filter((f: Option) => f.name.length > 1),\n      getFlagNames = map((f: Option) => f.name),\n      possibilities = getFlagNames([\n        ...longFlags(command.options),\n        ...getGlobalOptions().keys(),\n      ]),\n      suggestions = getSuggestions(flag, possibilities)\n\n    let msg = `Unknown option ${c.bold.redBright(getDashedOpt(flag))}. `\n    if (suggestions.length) {\n      msg +=\n        \"Did you mean \" +\n        suggestions\n          .map((s) => boldDiffString(getDashedOpt(flag), getDashedOpt(s)))\n          .join(\" or maybe \") +\n        \" ?\"\n    }\n    super(msg, { flag, command })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { getSuggestions, boldDiffString } from \"../utils/suggest\"\nimport chalk from \"chalk\"\nimport type { Program } from \"../program\"\nimport flatMap from \"lodash/flatMap\"\nimport filter from \"lodash/filter\"\n\n/**\n * @todo Rewrite\n */\nexport class UnknownOrUnspecifiedCommandError extends BaseError {\n  constructor(program: Program, command?: string) {\n    const possibilities = filter(\n      flatMap(program.getCommands(), (c) => [c.name, ...c.getAliases()]),\n    )\n    let msg = \"\"\n    if (command) {\n      msg = `Unknown command ${chalk.bold(command)}.`\n      const suggestions = getSuggestions(command, possibilities)\n      if (suggestions.length) {\n        msg +=\n          \" Did you mean \" +\n          suggestions.map((s) => boldDiffString(command, s)).join(\" or maybe \") +\n          \" ?\"\n      }\n    } else {\n      msg =\n        \"Unspecified command. Available commands are:\\n\" +\n        possibilities.map((p) => chalk.whiteBright(p)).join(\", \") +\n        \".\" +\n        `\\n\\nFor more help, type ${chalk.whiteBright(program.getBin() + \" --help\")}`\n    }\n\n    super(msg, { command })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { format } from \"util\"\nimport c from \"chalk\"\nimport { BaseError } from \"./base\"\nimport { Validator, ParserTypes, Argument, Option, CaporalValidator } from \"../types\"\nimport { isCaporalValidator } from \"../validator/utils\"\n\ninterface ValidationErrorParameters {\n  value: ParserTypes | ParserTypes[]\n  error?: Error | string\n  validator: Validator\n  context: Argument | Option\n}\n\nfunction isOptionObject(obj: Option | Argument): obj is Option {\n  return \"allNotations\" in obj\n}\n\nexport class ValidationError extends BaseError {\n  constructor({ value, error, validator, context }: ValidationErrorParameters) {\n    let message = error instanceof Error ? error.message : error\n    const varName = isOptionObject(context) ? \"option\" : \"argument\"\n    const name = isOptionObject(context)\n      ? context.allNotations.join(\"|\")\n      : context.synopsis\n\n    if (isCaporalValidator(validator)) {\n      switch (validator) {\n        case CaporalValidator.NUMBER:\n          message = format(\n            'Invalid value for %s %s.\\nExpected a %s but got \"%s\".',\n            varName,\n            c.redBright(name),\n            c.underline(\"number\"),\n            c.redBright(value),\n          )\n          break\n        case CaporalValidator.BOOLEAN:\n          message = format(\n            'Invalid value for %s %s.\\nExpected a %s (true, false, 0, 1), but got \"%s\".',\n            varName,\n            c.redBright(name),\n            c.underline(\"boolean\"),\n            c.redBright(value),\n          )\n          break\n        case CaporalValidator.STRING:\n          message = format(\n            'Invalid value for %s %s.\\nExpected a %s, but got \"%s\".',\n            varName,\n            c.redBright(name),\n            c.underline(\"string\"),\n            c.redBright(value),\n          )\n          break\n      }\n    } else if (Array.isArray(validator)) {\n      message = format(\n        'Invalid value for %s %s.\\nExpected one of %s, but got \"%s\".',\n        varName,\n        c.redBright(name),\n        \"'\" + validator.join(\"', '\") + \"'\",\n        c.redBright(value),\n      )\n    } else if (validator instanceof RegExp) {\n      message = format(\n        'Invalid value for %s %s.\\nExpected a value matching %s, but got \"%s\".',\n        varName,\n        c.redBright(name),\n        c.whiteBright(validator.toString()),\n        c.redBright(value),\n      )\n    }\n    super(message + \"\")\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { ArgumentsRange } from \"../types\"\nimport { Command } from \"../command\"\nimport { format } from \"util\"\nimport c from \"chalk\"\n\nexport class TooManyArgumentsError extends BaseError {\n  constructor(cmd: Command, range: ArgumentsRange, argsCount: number) {\n    const expArgsStr =\n      range.min === range.max\n        ? `exactly ${range.min}.`\n        : `between ${range.min} and ${range.max}.`\n\n    const cmdName = cmd.isProgramCommand() ? \"\" : `for command ${c.bold(cmd.name)}`\n    const message = format(\n      `Too many argument(s) %s. Got %s, expected %s`,\n      cmdName,\n      c.bold.redBright(argsCount),\n      c.bold.greenBright(expArgsStr),\n    )\n    super(message, { command: cmd })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { ParserTypes, Argument, Option } from \"../types\"\nimport { ValidationError } from \"../error\"\n\n/**\n * Validate using a RegExp\n *\n * @param validator\n * @param value\n * @ignore\n */\nexport function validateWithRegExp(\n  validator: RegExp,\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n): ParserTypes | ParserTypes[] {\n  if (Array.isArray(value)) {\n    return value.map((v) => {\n      return validateWithRegExp(validator, v, context) as ParserTypes\n    })\n  }\n  if (!validator.test(value + \"\")) {\n    throw new ValidationError({\n      validator: validator,\n      value,\n      context,\n    })\n  }\n  return value\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { ParserTypes, Argument, Option } from \"../types\"\nimport { ValidationError } from \"../error\"\n\n/**\n * Validate using an array of valid values.\n *\n * @param validator\n * @param value\n * @ignore\n */\nexport function validateWithArray(\n  validator: ParserTypes[],\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n): ParserTypes | ParserTypes[] {\n  if (Array.isArray(value)) {\n    value.forEach((v) => validateWithArray(validator, v, context))\n  } else if (validator.includes(value) === false) {\n    throw new ValidationError({\n      validator,\n      value,\n      context,\n    })\n  }\n  return value\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { ParserTypes, FunctionValidator, Argument, Option } from \"../types\"\nimport { ValidationError } from \"../error\"\n\nexport async function validateWithFunction(\n  validator: FunctionValidator,\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n): Promise<ParserTypes | ParserTypes[]> {\n  if (Array.isArray(value)) {\n    return Promise.all(\n      value.map((v) => {\n        return validateWithFunction(validator, v, context) as Promise<ParserTypes>\n      }),\n    )\n  }\n  try {\n    return await validator(value)\n  } catch (error) {\n    throw new ValidationError({\n      validator,\n      value,\n      error,\n      context,\n    })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { ParserTypes, Argument, Option } from \"../types\"\nimport { CaporalValidator } from \"../types\"\nimport { ValidationError } from \"../error\"\nimport { isNumeric } from \"../option/utils\"\nimport flatMap from \"lodash/flatMap\"\n\nimport {\n  isNumericValidator,\n  isStringValidator,\n  isBoolValidator,\n  isArrayValidator,\n} from \"./utils\"\n\n// Re-export for convenience\nexport { CaporalValidator }\n\nexport function validateWithCaporal(\n  validator: CaporalValidator,\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n  skipArrayValidation = false,\n): ParserTypes | ParserTypes[] {\n  if (!skipArrayValidation && isArrayValidator(validator)) {\n    return validateArrayFlag(validator, value, context)\n  } else if (Array.isArray(value)) {\n    // should not happen!\n    throw new ValidationError({\n      error: \"Expected a scalar value, got an array\",\n      value,\n      validator,\n      context,\n    })\n  } else if (isNumericValidator(validator)) {\n    return validateNumericFlag(validator, value, context)\n  } else if (isStringValidator(validator)) {\n    return validateStringFlag(value)\n  } else if (isBoolValidator(validator)) {\n    return validateBoolFlag(value, context)\n  }\n  return value\n}\n\n/**\n * The string validator actually just cast the value to string\n *\n * @param value\n * @ignore\n */\nexport function validateBoolFlag(\n  value: ParserTypes,\n  context: Argument | Option,\n): boolean {\n  if (typeof value === \"boolean\") {\n    return value\n  } else if (/^(true|false|yes|no|0|1)$/i.test(String(value)) === false) {\n    throw new ValidationError({\n      value,\n      validator: CaporalValidator.BOOLEAN,\n      context,\n    })\n  }\n  return /^0|no|false$/.test(String(value)) === false\n}\n\nexport function validateNumericFlag(\n  validator: number,\n  value: ParserTypes,\n  context: Argument | Option,\n): number {\n  const str = value + \"\"\n  if (Array.isArray(value) || !isNumeric(str)) {\n    throw new ValidationError({\n      value,\n      validator,\n      context,\n    })\n  }\n  return parseFloat(str)\n}\n\nexport function validateArrayFlag(\n  validator: number,\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n): ParserTypes | ParserTypes[] {\n  const values: ParserTypes[] =\n    typeof value === \"string\" ? value.split(\",\") : !Array.isArray(value) ? [value] : value\n  return flatMap(values, (el) => validateWithCaporal(validator, el, context, true))\n}\n\n/**\n * The string validator actually just cast the value to string\n *\n * @param value\n * @ignore\n */\nexport function validateStringFlag(value: ParserTypes | ParserTypes[]): string {\n  return value + \"\"\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type {\n  Validator,\n  Promisable,\n  ParsedOption,\n  ParsedArgument,\n  Argument,\n  Option,\n} from \"../types\"\n\nimport { validateWithRegExp } from \"./regexp\"\nimport { validateWithArray } from \"./array\"\nimport { validateWithFunction } from \"./function\"\nimport { validateWithCaporal } from \"./caporal\"\nimport { isCaporalValidator } from \"./utils\"\n\nexport function validate(\n  value: ParsedOption | ParsedArgument,\n  validator: Validator,\n  context: Argument | Option,\n): Promisable<ParsedOption | ParsedArgument> {\n  if (typeof validator === \"function\") {\n    return validateWithFunction(validator, value, context)\n  } else if (validator instanceof RegExp) {\n    return validateWithRegExp(validator, value, context)\n  } else if (Array.isArray(validator)) {\n    return validateWithArray(validator, value, context)\n  }\n  // Caporal flag validator\n  else if (isCaporalValidator(validator)) {\n    return validateWithCaporal(validator, value, context)\n  }\n  return value\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { Argument } from \"../types\"\nimport type { Command } from \"../command\"\n\nexport function findArgument(cmd: Command, name: string): Argument | undefined {\n  return cmd.args.find((a) => a.name === name)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport reduce from \"lodash/reduce\"\nimport { findOption } from \"./find\"\nimport { MissingFlagError, UnknownOptionError, CommonError } from \"../error\"\nimport { findGlobalOption } from \".\"\nimport { validate } from \"../validator/validate\"\n\nimport type { ParsedOption, ParsedOptions, Promisable, Option } from \"../types\"\nimport type { Command } from \"../command\"\n\nfunction validateOption(opt: Option, value: ParsedOption): ReturnType<typeof validate> {\n  return opt.validator ? validate(value, opt.validator, opt) : value\n}\n\nexport function checkRequiredOpts(cmd: Command, opts: ParsedOptions) {\n  return cmd.options.reduce((acc, opt) => {\n    if (opts[opt.name] === undefined && opt.required) {\n      acc.push(new MissingFlagError(opt, cmd))\n    }\n    return acc\n  }, [] as CommonError[])\n}\n\nfunction applyDefaults(cmd: Command, opts: ParsedOptions): ParsedOptions {\n  return cmd.options.reduce((acc, opt) => {\n    if (acc[opt.name] === undefined && opt.default !== undefined) {\n      acc[opt.name] = opt.default\n    }\n    return acc\n  }, opts)\n}\n\ntype OptionsPromises = Record<string, Promisable<ParsedOption>>\n\ninterface OptionsValidationResult {\n  options: ParsedOptions\n  errors: CommonError[]\n}\n\nexport async function validateOptions(\n  cmd: Command,\n  options: ParsedOptions,\n): Promise<OptionsValidationResult> {\n  options = applyDefaults(cmd, options)\n  const errors: CommonError[] = []\n  const validations = reduce(\n    options,\n    (...args) => {\n      const [acc, value, name] = args\n      const opt = findGlobalOption(name) || findOption(cmd, name)\n      try {\n        if (opt) {\n          acc[name] = validateOption(opt, value)\n        } else if (cmd.strictOptions) {\n          throw new UnknownOptionError(name, cmd)\n        }\n      } catch (e) {\n        errors.push(e)\n      }\n      return acc\n    },\n    {} as OptionsPromises,\n  )\n  const result = await reduce(\n    validations,\n    async (prevPromise, value, key): Promise<ParsedOptions> => {\n      const collection = await prevPromise\n      collection[key] = await value\n      return collection\n    },\n    Promise.resolve({}) as Promise<ParsedOptions>,\n  )\n\n  errors.push(...checkRequiredOpts(cmd, result))\n  return { options: result, errors }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { Command } from \"../command\"\nimport type { Option } from \"../types\"\n\n/**\n * Find an option from its name for a given command\n *\n * @param cmd Command object\n * @param name Option name, short or long, camel-cased\n */\nexport function findOption(cmd: Command, name: string): Option | undefined {\n  return cmd.options.find((o) => o.allNames.find((opt) => opt === name))\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport { ParserResult, ParserProcessedResult } from \"../types\"\nimport { validateArgs } from \"../argument/validate\"\nimport { validateOptions } from \"../option/validate\"\nimport type { Command } from \".\"\n\nexport async function validateCall(\n  cmd: Command,\n  result: ParserResult,\n): Promise<ParserProcessedResult> {\n  const { args: parsedArgs, options: parsedFlags } = result\n  // check if there are some global flags to handle\n  const { options: flags, errors: flagsErrors } = await validateOptions(cmd, parsedFlags)\n  const { args, errors: argsErrors } = await validateArgs(cmd, parsedArgs)\n  return { ...result, args, options: flags, errors: [...argsErrors, ...flagsErrors] }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { ArgumentSynopsis } from \"../types\"\nimport { getCleanNameFromNotation } from \"../option/utils\"\n\n/**\n * Check if the argument is explicitly required\n *\n * @ignore\n * @param synopsis\n */\nexport function isRequired(synopsis: string): boolean {\n  return synopsis.substring(0, 1) === \"<\"\n}\n\n/**\n *\n * @param synopsis\n */\nexport function isVariadic(synopsis: string): boolean {\n  return synopsis.substr(-4, 3) === \"...\" || synopsis.endsWith(\"...\")\n}\n\nexport function parseArgumentSynopsis(synopsis: string): ArgumentSynopsis {\n  synopsis = synopsis.trim()\n  const rawName = getCleanNameFromNotation(synopsis, false)\n  const name = getCleanNameFromNotation(synopsis)\n  const required = isRequired(synopsis)\n  const variadic = isVariadic(synopsis)\n  const cleanSynopsis = required\n    ? `<${rawName}${variadic ? \"...\" : \"\"}>`\n    : `[${rawName}${variadic ? \"...\" : \"\"}]`\n  return {\n    name,\n    synopsis: cleanSynopsis,\n    required,\n    variadic,\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { Argument, CreateArgumentOpts } from \"../types\"\nimport { checkValidator, getTypeHint } from \"../validator/utils\"\nimport { parseArgumentSynopsis } from \"./synopsis\"\n\n/**\n *\n * @param synopsis - Argument synopsis\n * @param description - Argument description\n * @param [options] - Various argument options like validator and default value\n */\nexport function createArgument(\n  synopsis: string,\n  description: string,\n  options: CreateArgumentOpts = {},\n): Argument {\n  const { validator, default: defaultValue } = options\n  checkValidator(validator)\n\n  const syno = parseArgumentSynopsis(synopsis)\n  const arg: Argument = {\n    kind: \"argument\",\n    default: defaultValue,\n    description,\n    choices: Array.isArray(validator) ? validator : [],\n    validator,\n    ...syno,\n  }\n  arg.typeHint = getTypeHint(arg)\n\n  return arg\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { Command } from \"../command\"\nimport map from \"lodash/map\"\nimport zipObject from \"lodash/zipObject\"\nimport invert from \"lodash/invert\"\nimport pickBy from \"lodash/pickBy\"\n\nexport function getOptsMapping(cmd: Command): Record<string, string> {\n  const names = map(cmd.options, \"name\")\n  const aliases = map(cmd.options, (o) => o.shortName || o.longName)\n  const result = zipObject(names, aliases)\n  return pickBy({ ...result, ...invert(result) }) as Record<string, string>\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { BaseConfig, Configurator } from \"../types\"\n\nexport function createConfigurator<T extends BaseConfig>(defaults: T): Configurator<T> {\n  const _defaults = defaults\n  let config = defaults\n  return {\n    reset(): T {\n      config = _defaults\n      return config\n    },\n    get<K extends keyof T>(key: K): T[K] {\n      return config[key]\n    },\n    getAll(): T {\n      return config\n    },\n    set(props: Partial<T>): T {\n      config = { ...config, ...props }\n      return config\n    },\n  }\n}\n","/**\n * @packageDocumentation\n * @module caporal/command\n */\nimport { validateCall } from \"./validate-call\"\nimport { logger } from \"../logger\"\nimport { createArgument } from \"../argument\"\nimport { createOption, processGlobalOptions } from \"../option\"\nimport { registerCompletion } from \"../autocomplete\"\nimport { Completer } from \"../autocomplete/types\"\nimport { getOptsMapping } from \"../option/mapping\"\nimport { isStringValidator, isBoolValidator } from \"../validator/utils\"\nimport type { Program } from \"../program\"\nimport { ActionError, NoActionError, BaseError, ValidationSummaryError } from \"../error\"\nimport {\n  Action,\n  ParserOptions,\n  ParserResult,\n  Option,\n  Argument,\n  CreateArgumentOpts,\n  Configurator,\n  CommandConfig,\n  CreateOptionCommandOpts,\n} from \"../types\"\nimport { CustomizedHelpOpts } from \"../help/types\"\nimport { customizeHelp } from \"../help\"\nimport { createConfigurator } from \"../config\"\n\n/**\n * @ignore\n */\nexport const PROG_CMD = \"__self_cmd\"\n\n/**\n * @ignore\n */\nexport const HELP_CMD = \"help\"\n\n/**\n * Command class\n *\n */\nexport class Command {\n  private program: Program\n  private _action?: Action\n  private _lastAddedArgOrOpt?: Argument | Option\n  private _aliases: string[] = []\n  private _name: string\n  private _config: Configurator<CommandConfig>\n  /**\n   * Command description\n   *\n   * @internal\n   */\n  readonly description: string\n  /**\n   * Command options array\n   *\n   * @internal\n   */\n  readonly options: Option[] = []\n  /**\n   * Command arguments array\n   *\n   * @internal\n   */\n  readonly args: Argument[] = []\n\n  /**\n   *\n   * @param program\n   * @param name\n   * @param description\n   * @internal\n   */\n  constructor(\n    program: Program,\n    name: string,\n    description: string,\n    config: Partial<CommandConfig> = {},\n  ) {\n    this.program = program\n    this._name = name\n    this.description = description\n    this._config = createConfigurator({ visible: true, ...config })\n  }\n\n  /**\n   * Add one or more aliases so the command can be called by different names.\n   *\n   * @param aliases Command aliases\n   */\n  alias(...aliases: string[]): Command {\n    this._aliases.push(...aliases)\n    return this\n  }\n\n  /**\n   * Name getter. Will return an empty string in the program-command context\n   *\n   * @internal\n   */\n  get name(): string {\n    return this.isProgramCommand() ? \"\" : this._name\n  }\n\n  /**\n   * Add an argument to the command.\n   * Synopsis is a string like `<my-argument>` or `[my-argument]`.\n   * Angled brackets (e.g. `<item>`) indicate required input. Square brackets (e.g. `[env]`) indicate optional input.\n   *\n   * Returns the {@link Command} object to facilitate chaining of methods.\n   *\n   * @param synopsis Argument synopsis.\n   * @param description - Argument description.\n   * @param [options] - Optional parameters including validator and default value.\n   */\n  argument(\n    synopsis: string,\n    description: string,\n    options: CreateArgumentOpts = {},\n  ): Command {\n    this._lastAddedArgOrOpt = createArgument(synopsis, description, options)\n    this.args.push(this._lastAddedArgOrOpt)\n    return this\n  }\n\n  /**\n   * Set the corresponding action to execute for this command\n   *\n   * @param action Action to execute\n   */\n  action(action: Action): Command {\n    this._action = action\n    return this\n  }\n\n  /**\n   * Allow chaining command() calls. See {@link Program.command}.\n   *\n   */\n  command(\n    name: string,\n    description: string,\n    config: Partial<CommandConfig> = {},\n  ): Command {\n    return this.program.command(name, description, config)\n  }\n\n  /**\n   * Makes the command the default one for the program.\n   */\n  default(): Command {\n    this.program.defaultCommand = this\n    return this\n  }\n\n  /**\n   * Checks if the command has the given alias registered.\n   *\n   * @param alias\n   * @internal\n   */\n  hasAlias(alias: string): boolean {\n    return this._aliases.includes(alias)\n  }\n\n  /**\n   * Get command aliases.\n   * @internal\n   */\n  getAliases(): string[] {\n    return this._aliases\n  }\n\n  /**\n   * @internal\n   */\n  isProgramCommand(): boolean {\n    return this._name === PROG_CMD\n  }\n\n  /**\n   * @internal\n   */\n  isHelpCommand(): boolean {\n    return this._name === HELP_CMD\n  }\n\n  /**\n   * Hide the command from help.\n   * Shortcut to calling `.configure({ visible: false })`.\n   */\n  hide(): Command {\n    return this.configure({ visible: false })\n  }\n\n  /**\n   * Add an option to the current command.\n   *\n   * @param synopsis Option synopsis like '-f, --force', or '-f, --file \\<file\\>', or '--with-openssl [path]'\n   * @param description Option description\n   * @param options Additional parameters\n   */\n  option(\n    synopsis: string,\n    description: string,\n    options: CreateOptionCommandOpts = {},\n  ): Command {\n    const opt = (this._lastAddedArgOrOpt = createOption(synopsis, description, options))\n    this.options.push(opt)\n    return this\n  }\n\n  /**\n   * @internal\n   */\n  getParserConfig(): Partial<ParserOptions> {\n    const defaults: ParserOptions = {\n      boolean: [],\n      string: [],\n      alias: getOptsMapping(this),\n      autoCast: this.autoCast,\n      variadic: [],\n      ddash: false,\n    }\n    let parserOpts = this.options.reduce((parserOpts, opt) => {\n      if (opt.boolean) {\n        parserOpts.boolean.push(opt.name)\n      }\n      if (isStringValidator(opt.validator)) {\n        parserOpts.string.push(opt.name)\n      }\n      if (opt.variadic) {\n        parserOpts.variadic.push(opt.name)\n      }\n      return parserOpts\n    }, defaults)\n\n    parserOpts = this.args.reduce((parserOpts, arg, index) => {\n      if (!this.isProgramCommand()) {\n        index++\n      }\n      if (isBoolValidator(arg.validator)) {\n        parserOpts.boolean.push(index)\n      }\n      if (isStringValidator(arg.validator)) {\n        parserOpts.string.push(index)\n      }\n      if (arg.variadic) {\n        parserOpts.variadic.push(index)\n      }\n      return parserOpts\n    }, parserOpts)\n\n    return parserOpts\n  }\n\n  /**\n   * Return a reformated synopsis string\n   * @internal\n   */\n  get synopsis(): string {\n    const opts = this.options.length\n      ? this.options.some((f) => f.required)\n        ? \"<OPTIONS...>\"\n        : \"[OPTIONS...]\"\n      : \"\"\n    const name = this._name !== PROG_CMD ? \" \" + this._name : \"\"\n\n    return (\n      this.program.getBin() +\n      name +\n      \" \" +\n      this.args.map((a) => a.synopsis).join(\" \") +\n      \" \" +\n      opts\n    ).trim()\n  }\n\n  /**\n   * Customize command help. Can be called multiple times to add more paragraphs and/or sections.\n   *\n   * @param text Help contents\n   * @param options Display options\n   */\n  help(text: string, options: Partial<CustomizedHelpOpts> = {}): Command {\n    customizeHelp(this, text, options)\n    return this\n  }\n\n  /**\n   * Configure some behavioral properties.\n   *\n   * @param props properties to set/update\n   */\n  configure(props: Partial<CommandConfig>): Command {\n    this._config.set(props)\n    return this\n  }\n\n  /**\n   * Get a configuration property value.\n   *\n   * @internal\n   * @param key Property key to get value for. See {@link CommandConfig}.\n   */\n  getConfigProperty<K extends keyof CommandConfig>(key: K): CommandConfig[K] {\n    return this._config.get(key)\n  }\n\n  /**\n   * Get the auto-casting flag.\n   *\n   * @internal\n   */\n  get autoCast(): boolean {\n    return (\n      this.getConfigProperty(\"autoCast\") ?? this.program.getConfigProperty(\"autoCast\")\n    )\n  }\n\n  /**\n   * Auto-complete\n   */\n  complete(completer: Completer): Command {\n    if (!this._lastAddedArgOrOpt) {\n      throw new Error(\n        \"Caporal setup error: you should only call `.complete()` after .argument() or .option().\",\n      )\n    }\n    registerCompletion(this._lastAddedArgOrOpt, completer)\n    return this\n  }\n\n  /**\n   * Toggle strict mode.\n   * Shortcut to calling: `.configure({ strictArgsCount: strict, strictOptions: strict }).\n   * By default, strict settings are not defined for commands, and inherit from the\n   * program settings. Calling `.strict(value)` on a command will override the program\n   * settings.\n   *\n   * @param strict boolean enabled flag\n   */\n  strict(strict = true): Command {\n    return this.configure({\n      strictArgsCount: strict,\n      strictOptions: strict,\n    })\n  }\n\n  /**\n   * Computed strictOptions flag.\n   *\n   * @internal\n   */\n  get strictOptions(): boolean {\n    return (\n      this.getConfigProperty(\"strictOptions\") ??\n      this.program.getConfigProperty(\"strictOptions\")\n    )\n  }\n  /**\n   * Computed strictArgsCount flag.\n   *\n   * @internal\n   */\n  get strictArgsCount(): boolean {\n    return (\n      this.getConfigProperty(\"strictArgsCount\") ??\n      this.program.getConfigProperty(\"strictArgsCount\")\n    )\n  }\n\n  /**\n   * Enable or disable auto casting of arguments & options for the command.\n   * This is basically a shortcut to calling `command.configure({ autoCast: enabled })`.\n   * By default, auto-casting is inherited from the program configuration.\n   * This method allows overriding what's been set on the program level.\n   *\n   * @param enabled\n   */\n  cast(enabled: boolean): Command {\n    return this.configure({ autoCast: enabled })\n  }\n\n  /**\n   * Visible flag\n   *\n   * @internal\n   */\n  get visible(): boolean {\n    return this.getConfigProperty(\"visible\")\n  }\n\n  /**\n   * Run the action associated with the command\n   *\n   * @internal\n   */\n  async run(parsed: Partial<ParserResult>): Promise<unknown> {\n    const data: ParserResult = {\n      args: [],\n      options: {},\n      line: \"\",\n      rawOptions: {},\n      rawArgv: [],\n      ddash: [],\n      ...parsed,\n    }\n\n    try {\n      // Validate args and options, including global options\n      const result = await validateCall(this, data)\n      const { args, options, ddash, errors } = result\n\n      // Process any global options\n      const shouldStop = await processGlobalOptions(result, this.program, this)\n      if (shouldStop) {\n        return -1\n      }\n\n      if (errors.length) {\n        throw new ValidationSummaryError(this, errors)\n      }\n\n      if (!this._action) {\n        throw new NoActionError(this)\n      }\n\n      return await this._action({\n        args,\n        options,\n        ddash,\n        logger,\n        program: this.program,\n        command: this,\n      })\n    } catch (err) {\n      const ctor = Object.getPrototypeOf(err).constructor.name\n      throw err instanceof BaseError && ctor !== \"Error\"\n        ? err\n        : new ActionError(err as Error)\n    }\n  }\n}\n\n/**\n * Create a new command\n *\n * @internal\n */\nexport function createCommand(\n  ...args: ConstructorParameters<typeof Command>\n): InstanceType<typeof Command> {\n  return new Command(...args)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport path from \"path\"\nimport zipObject from \"lodash/zipObject\"\nimport map from \"lodash/map\"\nimport { readdir } from \"../utils/fs\"\nimport { importCommand } from \"./import\"\nimport { createCommand } from \".\"\nimport type { Command } from \".\"\nimport type { Program } from \"../program\"\n\nexport async function scanCommands(\n  program: Program,\n  dirPath: string,\n): Promise<Command[]> {\n  const files = await readdir(dirPath)\n  const imp = await Promise.all(files.map((f) => importCommand(path.join(dirPath, f))))\n  const data = zipObject(files, imp)\n  return map(data, (cmdBuilder, filename) => {\n    const { dir, name } = path.parse(filename)\n    const cmd = dir ? [...dir.split(\"/\"), name].join(\" \") : name\n    const options = {\n      createCommand: createCommand.bind(null, program, cmd),\n      program,\n    }\n    return cmdBuilder(options)\n  })\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport { glob } from \"glob\"\nimport fs from \"fs\"\n\nexport function readdir(dirPath: string, extensions = \"js,ts\"): Promise<string[]> {\n  if (!fs.existsSync(dirPath)) {\n    return Promise.reject(new Error(`'${dirPath}' does not exist!`))\n  }\n  return glob(`**/*.{${extensions}}`, { cwd: dirPath })\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport path from \"path\"\n\nexport function detectVersion(): string | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return require(path.join(__filename, \"..\", \"..\", \"..\", \"package.json\")).version\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n}\n","/**\n * Main Caporal module.\n *\n * ## program\n *\n * This represents your program. You don't have to instanciate the {@link Program} class,\n * it's already done for you.\n *\n * **Usage**\n *\n * ```ts\n * // The Program instance generated for you\n * import program from \"@caporal/core\"\n *\n * program\n *  .command(...)\n *  .action(...)\n * [...]\n * ```\n *\n *\n * ## parseArgv()\n *\n *  This is the command line parser internaly used by Caporal.\n *\n * ::: tip Advanced usage\n * Usually, **you won't need to use the parser** directly, but if you\n * just want to parse some args without all capabilities brought\n * by Caporal, feel free to play with it.\n * :::\n *\n * **Usage**\n *\n * ```ts\n * import { parseArgv } from \"@caporal/core\"\n *\n * const {args, options} = parseArgv({\n *  // ... options\n * })\n * ```\n *\n * Checkout `parseArgv()` [documentation here](/api/modules/parser.md).\n *\n *\n * ## chalk\n *\n * `chalk` npm module re-export\n *\n * **Usage**\n *\n * ```ts\n * import { program, chalk } from \"caporal\"\n *\n * program\n *  .command('pay')\n *  .argument('<amount>', 'Amount to pay', Validator.NUMBER)\n *  .action(({logger, args}) => {\n *    logger.info(\"You paid $%s\", chalk.red(args.amount))\n *  })\n * [...]\n * ```\n *\n *\n * @packageDocumentation\n * @module @caporal/core\n */\nimport { Program } from \"./program\"\nexport { Command } from \"./command\"\nexport * from \"./types\"\n\n/**\n * @ignore\n */\nexport { default as chalk } from \"chalk\"\n/**\n * @ignore\n */\nexport { parseArgv, parseLine } from \"./parser\"\n\n/**\n * @ignore\n */\nexport const program = new Program()\n\n/**\n * @ignore\n */\nexport default program\n\n/**\n * @ignore\n */\nexport { Program }\n"],"mappings":"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","names":["EventEmitter","fs","path","kebabCase","mapKeys","reduce","BaseError","message","meta","ActionError","BaseError","error","message","winstonCreateLogger","transports","format","inspect","chalk","supportsColor","replace","EOL","caporalFormat","data","level","meta","message","prefix","levelStr","getLevelString","metaStr","formatMeta","spaces","logger","createDefaultLogger","setLogger","loggerObj","getLogger","fatalError","error","logger","InvalidValidatorError","BaseError","validator","chalk","MissingArgumentError","BaseError","argument","command","msg","chalk","MissingFlagError","BaseError","flag","command","msg","chalk","c","colorize","text","match","ValidationSummaryError","BaseError","cmd","errors","msg","e","chalk","colorize","NoActionError","BaseError","cmd","message","OptionSynopsisSyntaxError","BaseError","synopsis","camelCase","kebabCase","CaporalValidator","OptionValueType","REG_SHORT_OPT","REG_LONG_OPT","REG_OPT","isShortOpt","flag","isLongOpt","camelCaseOpt","name","camelCase","getCleanNameFromNotation","str","camelCased","getDashedOpt","l","kebabCase","isNumeric","n","isOptionStr","isConcatenatedOpt","isNegativeOpt","opt","isOptArray","formatOptName","parseOptionSynopsis","synopsis","analysis","infos","acc","value","OptionSynopsisSyntaxError","isNumber","isCaporalValidator","validator","getCaporalValidatorsMask","isNumericValidator","isStringValidator","isBoolValidator","isArrayValidator","CaporalValidator","isNumber","a","b","checkCaporalValidator","InvalidValidatorError","checkUserDefinedValidator","checkValidator","getTypeHint","obj","hint","stringified","replace","chalk","table","getBorderCharacters","filter","buildTable","data","options","getDefaultValueHint","obj","getOptionSynopsisHelp","opt","crlf","c","getOptionsTable","ctx","title","spaces","help","rows","def","more","d","syno","desc","getArgumentsTable","args","eol","eol2","a","getCommandsTable","commands","chalk","prog","cmdHint","cmd","templates_exports","__export","command","custom","header","program","usage","sortBy","command","ctx","cmd","globalFlags","eol","eol3","colorize","tpl","options","globalOptions","help","getArgumentsTable","getOptionsTable","header","ctx","prog","c","spaces","eol","eol2","version","program","ctx","prog","globalOptions","eol","eol3","colorize","tpl","commands","options","help","getCommandsTable","getOptionsTable","usage","ctx","tpl","prog","c","spaces","eol","cmd","next","custom","ctx","prog","cmd","eol2","eol3","chalk","colorize","customHelp","indent","data","txt","text","options","str","subtxt","templates","templates_exports","customHelpMap","customizeHelp","obj","text","options","opts","data","tpl","name","ctx","template","templates","getContext","program","command","spaces","chalk","colorize","customHelpMap","getGlobalOptions","buildTable","str","sp","replace","getHelp","tabtab","invert","findIndex","DDASH","isDdash","str","castAsBool","value","castAsString","val","autoCast","isNumeric","cast","name","options","cleanName","formatOptName","parseLine","line","parseArgv","getNextOptPosition","args","ddash","opt","findIndex","isOptionStr","Tree","argv","start","end","by","ArgumentParser","config","argsLen","tree","values","until","OptionParser","next","nextIsOptOrUndef","names","last","alias","rawval","concatOpts","isConcatenatedOpt","no","isNegativeOpt","prop","isOptArray","multi","n","o","index","parseOpts","invert","flagParser","argParser","visitors","v","path","importCommand","file","dir","name","mod","path","findCommand","program","argv","commands","findRegisteredCommand","search","c","foundCommand","i","cmd","discoverCommand","filename","fullPath","cmdBuilder","importCommand","options","createCommand","filter","flatMap","completions","registerCompletion","argOrOpt","completer","installCompletion","program","tabtab","uninstallCompletion","createOption","synopsis","description","options","validator","required","hidden","checkValidator","syno","parseOptionSynopsis","boolean","isBoolValidator","opt","getTypeHint","showHelp","program","command","help","getHelp","showVersion","disableColors","logger","setVerbose","setQuiet","setSilent","installComp","installCompletion","uninstallComp","uninstallCompletion","globalOptions","getGlobalOptions","setupGlobalOptions","createOption","verbose","quiet","silent","version","color","installCompOpt","uninstallCompOpt","disableGlobalOption","name","opts","getGlobalOptions","opt","addGlobalOption","action","processGlobalOptions","parsed","program","command","options","actionsParams","logger","promises","findGlobalOptAction","r","findGlobalOption","chalk","levenshtein","a","b","cell","lcell","dcell","row","j","MAX_DISTANCE","sortByDistance","a","b","keepMeaningfulSuggestions","s","possibilitesMapper","input","p","levenshtein","getSuggestions","possibilities","boldDiffString","from","to","char","index","chalk","c","filter","map","UnknownOptionError","BaseError","flag","command","longFlags","f","getFlagNames","possibilities","getGlobalOptions","suggestions","getSuggestions","msg","getDashedOpt","s","boldDiffString","chalk","flatMap","filter","UnknownOrUnspecifiedCommandError","BaseError","program","command","possibilities","c","msg","suggestions","getSuggestions","s","boldDiffString","p","format","c","isOptionObject","obj","ValidationError","BaseError","value","error","validator","context","message","varName","name","isCaporalValidator","format","c","format","c","TooManyArgumentsError","BaseError","cmd","range","argsCount","expArgsStr","cmdName","message","validateWithRegExp","validator","value","context","v","ValidationError","validateWithArray","validator","value","context","v","ValidationError","validateWithFunction","validator","value","context","v","error","ValidationError","flatMap","validateWithCaporal","validator","value","context","skipArrayValidation","isArrayValidator","validateArrayFlag","ValidationError","isNumericValidator","validateNumericFlag","isStringValidator","validateStringFlag","isBoolValidator","validateBoolFlag","str","isNumeric","values","flatMap","el","validate","value","validator","context","validateWithFunction","validateWithRegExp","validateWithArray","isCaporalValidator","validateWithCaporal","findArgument","cmd","name","a","getRequiredArgsCount","cmd","a","getArgsObjectFromArray","args","result","acc","arg","index","hasVariadicArgument","getArgsRange","min","max","checkRequiredArgs","parsedArgv","errors","MissingArgumentError","numArgsError","checkNumberOfArgs","range","argsCount","TooManyArgumentsError","removeCommandFromArgs","words","validateArg","value","validate","validateArgs","formatedArgs","argsObj","validations","reduce","key","findArgument","BaseError","e","prevPromise","collection","reduce","findOption","cmd","name","o","opt","validateOption","opt","value","validate","checkRequiredOpts","cmd","opts","acc","MissingFlagError","applyDefaults","validateOptions","options","errors","validations","reduce","args","name","findGlobalOption","findOption","UnknownOptionError","e","result","prevPromise","key","collection","validateCall","cmd","result","parsedArgs","parsedFlags","flags","flagsErrors","validateOptions","args","argsErrors","validateArgs","isRequired","synopsis","isVariadic","parseArgumentSynopsis","rawName","getCleanNameFromNotation","name","required","variadic","cleanSynopsis","createArgument","synopsis","description","options","validator","defaultValue","checkValidator","syno","parseArgumentSynopsis","arg","getTypeHint","map","zipObject","invert","pickBy","getOptsMapping","cmd","names","aliases","o","result","createConfigurator","defaults","_defaults","config","key","props","PROG_CMD","HELP_CMD","Command","program","name","description","config","createConfigurator","aliases","synopsis","options","createArgument","action","alias","opt","createOption","defaults","getOptsMapping","parserOpts","isStringValidator","arg","index","isBoolValidator","opts","f","a","text","customizeHelp","props","key","completer","registerCompletion","strict","enabled","parsed","data","result","validateCall","args","ddash","errors","processGlobalOptions","ValidationSummaryError","NoActionError","logger","err","ctor","BaseError","ActionError","createCommand","path","zipObject","map","glob","fs","readdir","dirPath","extensions","scanCommands","program","dirPath","files","readdir","imp","f","importCommand","path","data","zipObject","map","cmdBuilder","filename","dir","name","cmd","options","createCommand","path","detectVersion","__require","path","LOG_LEVEL_ENV_VAR","Program","EventEmitter","path","detectVersion","createConfigurator","err","fatalError","createCommand","PROG_CMD","HELP_CMD","actionParams","args","command","findCommand","showHelp","text","options","customizeHelp","strict","props","key","ver","name","desc","logger","setLogger","getLogger","disableGlobalOption","description","config","cmd","discoveredCommands","enabled","action","synopsis","opt","createOption","addGlobalOption","dirPath","stat","fs","scanCommands","argv","result","parseArgv","arg","loggerLevel","processedResult","processGlobalOptions","UnknownOrUnspecifiedCommandError","ret","ddash","mapKeys","v","kebabCase","default","program","Program","src_default"]}