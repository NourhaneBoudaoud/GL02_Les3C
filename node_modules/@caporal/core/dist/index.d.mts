import { EventEmitter } from 'events';
import { Logger as Logger$1 } from 'winston';
import tabtab from 'tabtab';
export { default as chalk } from 'chalk';

/**
 * @packageDocumentation
 * @internal
 */

type CommonError = Error | BaseError;
declare class BaseError extends Error {
    meta: ErrorMetadata;
    constructor(message: string, meta?: ErrorMetadata);
}

/**
 * List of Caporal type aliases.
 *
 * @packageDocumentation
 * @module caporal/types
 */

/**
 * The Caporal logger interface. It extends the [Winston](https://github.com/winstonjs/winston) Logger interface
 * and adds the following properties & methods.
 * @noInheritDoc
 */
interface Logger extends Logger$1 {
    /**
     * Allow to force disabling colors.
     */
    disableColors(): void;
    /**
     * Tells Caporal if colors are enabled or not.
     */
    colorsEnabled: boolean;
}
type GlobalOptions = Map<Option, Action | undefined>;
/**
 * Caporal-provided validator flags.
 */
declare enum CaporalValidator {
    /**
     * Number validator. Check that the value looks like a numeric one
     * and cast the provided value to a javascript `Number`.
     */
    NUMBER = 1,
    /**
     * Boolean validator. Check that the value looks like a boolean.
     * It accepts values like `true`, `false`, `yes`, `no`, `0`, and `1`
     * and will auto-cast those values to `true` or `false`.
     */
    BOOLEAN = 2,
    /**
     * String validator. Mainly used to make sure the value is a string,
     * and prevent Caporal auto-casting of numerics values and boolean
     * strings like `true` or `false`.
     */
    STRING = 4,
    /**
     * Array validator. Convert any provided value to an array. If a string is provided,
     * this validator will try to split it by commas.
     */
    ARRAY = 8
}
type FunctionValidatorArgument = ParsedArgument | ParsedOption;
interface FunctionValidator<T = FunctionValidatorArgument> {
    (value: T): Promisable<T>;
}
type Validator = RegExp | FunctionValidator | CaporalValidator | ParserTypes[];
/**
 * @internal
 */
interface ValidatorWrapper {
    validate(value: ParsedArgument | ParsedOption): ParserTypes | ParserTypes[] | Promise<ParserTypes>;
    getChoices(): ParserTypes[];
}
interface OptionSynopsis {
    name: string;
    notation: string;
    shortName?: string;
    shortNotation?: string;
    longName?: string;
    longNotation?: string;
    allNames: string[];
    allNotations: string[];
    synopsis: string;
    valueRequired: boolean;
    valueType?: OptionValueType;
    variadic: boolean;
}
/**
 * Option possible value.
 *
 */
declare enum OptionValueType {
    /**
     * Value is optional.
     */
    Optional = 0,
    /**
     * Value is required.
     */
    Required = 1,
    /**
     * Option does not have any possible value
     */
    None = 2
}
/**
 * Option properties
 */
interface CreateOptionCommandOpts {
    /**
     * Optional validator
     */
    validator?: Validator;
    /**
     * Default value for the Option
     */
    default?: ParsedOption;
    /**
     * Set the Option as itself required
     */
    required?: boolean;
    /**
     * Hide the option from help
     */
    hidden?: boolean;
}
/**
 * Option properties
 */
interface CreateOptionProgramOpts extends CreateOptionCommandOpts {
    /**
     * Set to `true` for a global option.
     */
    global?: boolean;
    /**
     * Action to call when a global-option is passed.
     * Only available for global options, e.g. when `global` is set to `true`.
     */
    action?: Action;
}
interface CreateArgumentOpts {
    /**
     * Argument validator.
     */
    validator?: Validator;
    /**
     * Argument default value.
     */
    default?: ParsedArgument;
}
interface ArgumentSynopsis {
    /**
     * Argument name.
     */
    readonly name: string;
    /**
     * Boolean indicating if the argument is required.
     */
    readonly required: boolean;
    /**
     * Synopsis string.
     */
    readonly synopsis: string;
    /**
     * Boolean indicating if the argument is valiadic,
     * e.g. can be repeated to contain an array of values.
     */
    readonly variadic: boolean;
}
interface Argument extends ArgumentSynopsis {
    readonly default?: ParsedArgument;
    readonly description: string;
    readonly choices: ParsedArgument[];
    readonly validator?: Validator;
    typeHint?: string;
    kind: "argument";
}
interface Option extends OptionSynopsis {
    readonly boolean: boolean;
    readonly default?: ParsedOption;
    readonly description: string;
    readonly choices: ParsedOption[];
    readonly validator?: Validator;
    readonly required: boolean;
    readonly visible: boolean;
    typeHint?: string;
    kind: "option";
}
/**
 * A type that could be wrapped in a Promise, or not
 */
type Promisable<T> = T | Promise<T>;
/**
 * Parameters object passed to an {@link Action} function
 */
interface ActionParameters {
    /**
     * Parsed command line arguments
     */
    args: ParsedArgumentsObject;
    /**
     * If the `dash` (double dash) config property is enabled,
     * this *array* will contain all arguments present
     * after '--'.
     */
    ddash: ParsedArguments;
    /**
     * Parsed command line options
     */
    options: ParsedOptions;
    /**
     * Program instance
     */
    program: Program;
    /**
     * Contextual command, if any
     */
    command?: Command;
    /**
     * Logger instance
     */
    logger: Logger;
}
/**
 * An action is a function that will be executed upon a command call.
 */
interface Action {
    (params: ActionParameters): unknown;
}
interface ErrorMetadata {
    [meta: string]: unknown;
}
type ParserTypes = string | number | boolean;
/**
 * Available options for the Caporal internal parser.
 * Arguments must be referenced by their position (0-based) and options by their name (short or long)
 * in {@link ParserOptions.boolean boolean}, {@link ParserOptions.string string}
 * and {@link ParserOptions.variadic variadic} parser options.
 *
 */
interface ParserOptions {
    /**
     * List of {@link Argument Arguments} and {@link Options Options} to be casted as *booleans*.
     * Arguments must be referenced by their position (0-based) and options by their name (short or long).
     *
     * **Example**
     *
     * ```ts
     * import { parseArgv } from "caporal/parser"
     *
     * parseArgv({
     *  boolean: [2, 'sendEmail']
     * })
     *
     * // ./my-cli-app first-arg second-arg 3rd-arg --sendEmail=1
     * // -> "3rd-arg" will be casted to boolean as well as "--sendEmail"
     * ```
     */
    boolean: (string | number)[];
    /**
     * List of {@link Argument Arguments} and {@link Options Options} to be casted as *strings*.
     * Arguments must be referenced by their position (0-based) and options by their name (short or long).
     *
     * **Example**
     *
     * ```ts
     * import { parseArgv } from "caporal/parser"
     *
     * parseArgv({
     *  string: [1]
     * })
     *
     * // ./my-cli-app first-arg 2
     * // -> second arg "2" will be casted to string instead of number
     * ```
     */
    string: (string | number)[];
    /**
     * List of variadic {@link Argument Arguments} and {@link Options Options}, meaning
     * that there value is an `Array`.
     *
     * Arguments must be referenced by their position (0-based) and options by their name (short or long).
     *
     * **Example**
     *
     * ```ts
     * import { parseArgv } from "caporal/parser"
     *
     * parseArgv({
     *  variadic: [1]
     * })
     *
     * // ./pizza order margherita regina --add sausages --add basil
     * {
     *   args: ['order', ['margherita', 'regina']]
     *   options: {
     *     add: ['sausages', 'basil']
     *   }
     * }
     * ```
     */
    variadic: (string | number)[];
    /**
     * Double-dash (--) handling mode. If `true`, the parser will populate the
     * {@link ParserResult.ddash} property, otherwise, arguments will be added
     * to {@link ParserResult.args}.
     */
    ddash: boolean;
    /**
     * Option aliases map.
     */
    alias: Record<string, string>;
    /**
     * Enable or disable autocasting of arguments and options. Default to `true`.
     */
    autoCast: boolean;
}
type ParsedArgument = ParserTypes | ParserTypes[];
type ParsedArguments = ParsedArgument[];
interface ParsedArgumentsObject {
    [arg: string]: ParsedArgument;
}
type ParsedOption = ParserTypes | ParserTypes[];
interface ParsedOptions {
    [opt: string]: ParsedOption;
}
/**
 * @internal
 */
interface ArgumentsRange {
    min: number;
    max: number;
}
interface ParserResult {
    args: ParsedArguments;
    options: ParsedOptions;
    rawOptions: ParsedOptions;
    line: string;
    rawArgv: string[];
    ddash: ParsedArguments;
}
interface ParserProcessedResult extends Omit<ParserResult, "args"> {
    args: ParsedArgumentsObject;
    errors: CommonError[];
}
interface CreateCommandParameters {
    program: Program;
    createCommand(description?: string): Command;
}
interface CommandCreator {
    (options: CreateCommandParameters): Command;
}
/**
 * Available configuration properties for the program.
 */
type ProgramConfig = {
    /**
     * Strict checking of arguments count. If enabled, any additional argument willl trigger an error.
     * Default to `true`.
     */
    strictArgsCount: boolean;
    /**
     * Strict checking of options provided. If enabled, any unknown option will trigger an error.
     * Default to `true`.
     */
    strictOptions: boolean;
    /**
     * Auto-casting of arguments and options.
     * Default to `true`.
     */
    autoCast: boolean;
    /**
     * Environment variable to check for log level override.
     * Default to "CAPORAL_LOG_LEVEL".
     */
    logLevelEnvVar: string;
};
type CommandConfig = {
    /**
     * Strict checking of arguments count. If enabled, any additional argument willl trigger an error.
     */
    strictArgsCount?: boolean;
    /**
     * Strict checking of options provided. If enabled, any unknown option will trigger an error.
     */
    strictOptions?: boolean;
    /**
     * Auto-casting of arguments and options.
     */
    autoCast?: boolean;
    /**
     * Visibility of the command in help.
     */
    visible: boolean;
};
type BaseConfig = Record<string, boolean | string>;
interface Configurator<T extends BaseConfig> {
    get<K extends keyof T>(key: K): T[K];
    getAll(): T;
    set(props: Partial<T>): T;
    reset(): T;
}

/**
 * @packageDocumentation
 * @module caporal/types
 */

interface CompletionItem {
    name: string;
    description: string;
}
interface Completer {
    (ctx: CompletionContext): Promisable<(string | CompletionItem)[]>;
}
interface CompletionContext {
    program: Program;
    currentCmd?: Command;
    compEnv: tabtab.TabtabEnv;
    parserResult: ParserResult;
    lastPartIsOpt: boolean;
    lastPartIsKnownOpt: boolean;
    currentOpt?: Option;
}

/**
 * @packageDocumentation
 * @module caporal/types
 */

interface CustomizedHelpOpts {
    /**
     * Name of the section to be added in help.
     */
    sectionName: string;
    /**
     * Enable or disable the automatic coloration of text.
     */
    colorize: boolean;
}

/**
 * Command class
 *
 */
declare class Command {
    private program;
    private _action?;
    private _lastAddedArgOrOpt?;
    private _aliases;
    private _name;
    private _config;
    /**
     * Command description
     *
     * @internal
     */
    readonly description: string;
    /**
     * Command options array
     *
     * @internal
     */
    readonly options: Option[];
    /**
     * Command arguments array
     *
     * @internal
     */
    readonly args: Argument[];
    /**
     *
     * @param program
     * @param name
     * @param description
     * @internal
     */
    constructor(program: Program, name: string, description: string, config?: Partial<CommandConfig>);
    /**
     * Add one or more aliases so the command can be called by different names.
     *
     * @param aliases Command aliases
     */
    alias(...aliases: string[]): Command;
    /**
     * Name getter. Will return an empty string in the program-command context
     *
     * @internal
     */
    get name(): string;
    /**
     * Add an argument to the command.
     * Synopsis is a string like `<my-argument>` or `[my-argument]`.
     * Angled brackets (e.g. `<item>`) indicate required input. Square brackets (e.g. `[env]`) indicate optional input.
     *
     * Returns the {@link Command} object to facilitate chaining of methods.
     *
     * @param synopsis Argument synopsis.
     * @param description - Argument description.
     * @param [options] - Optional parameters including validator and default value.
     */
    argument(synopsis: string, description: string, options?: CreateArgumentOpts): Command;
    /**
     * Set the corresponding action to execute for this command
     *
     * @param action Action to execute
     */
    action(action: Action): Command;
    /**
     * Allow chaining command() calls. See {@link Program.command}.
     *
     */
    command(name: string, description: string, config?: Partial<CommandConfig>): Command;
    /**
     * Makes the command the default one for the program.
     */
    default(): Command;
    /**
     * Checks if the command has the given alias registered.
     *
     * @param alias
     * @internal
     */
    hasAlias(alias: string): boolean;
    /**
     * Get command aliases.
     * @internal
     */
    getAliases(): string[];
    /**
     * @internal
     */
    isProgramCommand(): boolean;
    /**
     * @internal
     */
    isHelpCommand(): boolean;
    /**
     * Hide the command from help.
     * Shortcut to calling `.configure({ visible: false })`.
     */
    hide(): Command;
    /**
     * Add an option to the current command.
     *
     * @param synopsis Option synopsis like '-f, --force', or '-f, --file \<file\>', or '--with-openssl [path]'
     * @param description Option description
     * @param options Additional parameters
     */
    option(synopsis: string, description: string, options?: CreateOptionCommandOpts): Command;
    /**
     * @internal
     */
    getParserConfig(): Partial<ParserOptions>;
    /**
     * Return a reformated synopsis string
     * @internal
     */
    get synopsis(): string;
    /**
     * Customize command help. Can be called multiple times to add more paragraphs and/or sections.
     *
     * @param text Help contents
     * @param options Display options
     */
    help(text: string, options?: Partial<CustomizedHelpOpts>): Command;
    /**
     * Configure some behavioral properties.
     *
     * @param props properties to set/update
     */
    configure(props: Partial<CommandConfig>): Command;
    /**
     * Get a configuration property value.
     *
     * @internal
     * @param key Property key to get value for. See {@link CommandConfig}.
     */
    getConfigProperty<K extends keyof CommandConfig>(key: K): CommandConfig[K];
    /**
     * Get the auto-casting flag.
     *
     * @internal
     */
    get autoCast(): boolean;
    /**
     * Auto-complete
     */
    complete(completer: Completer): Command;
    /**
     * Toggle strict mode.
     * Shortcut to calling: `.configure({ strictArgsCount: strict, strictOptions: strict }).
     * By default, strict settings are not defined for commands, and inherit from the
     * program settings. Calling `.strict(value)` on a command will override the program
     * settings.
     *
     * @param strict boolean enabled flag
     */
    strict(strict?: boolean): Command;
    /**
     * Computed strictOptions flag.
     *
     * @internal
     */
    get strictOptions(): boolean;
    /**
     * Computed strictArgsCount flag.
     *
     * @internal
     */
    get strictArgsCount(): boolean;
    /**
     * Enable or disable auto casting of arguments & options for the command.
     * This is basically a shortcut to calling `command.configure({ autoCast: enabled })`.
     * By default, auto-casting is inherited from the program configuration.
     * This method allows overriding what's been set on the program level.
     *
     * @param enabled
     */
    cast(enabled: boolean): Command;
    /**
     * Visible flag
     *
     * @internal
     */
    get visible(): boolean;
    /**
     * Run the action associated with the command
     *
     * @internal
     */
    run(parsed: Partial<ParserResult>): Promise<unknown>;
}

/**
 * @packageDocumentation
 * @module caporal/program
 */

/**
 * Program class
 *
 * @noInheritDoc
 */
declare class Program extends EventEmitter {
    private commands;
    private _config;
    private _version?;
    private _name?;
    private _description?;
    private _programmaticMode;
    /**
     * @internal
     */
    defaultCommand?: Command;
    private _progCommand?;
    private _bin;
    private _discoveryPath?;
    private _discoveredCommands?;
    /**
     * Number validator. Check that the value looks like a numeric one
     * and cast the provided value to a javascript `Number`.
     */
    readonly NUMBER = CaporalValidator.NUMBER;
    /**
     * String validator. Mainly used to make sure the value is a string,
     * and prevent Caporal auto-casting of numerical values and boolean
     * strings like `true` or `false`.
     */
    readonly STRING = CaporalValidator.STRING;
    /**
     * Array validator. Convert any provided value to an array. If a string is provided,
     * this validator will try to split it by commas.
     */
    readonly ARRAY = CaporalValidator.ARRAY;
    /**
     * Boolean validator. Check that the value looks like a boolean.
     * It accepts values like `true`, `false`, `yes`, `no`, `0`, and `1`
     * and will auto-cast those values to `true` or `false`.
     */
    readonly BOOLEAN = CaporalValidator.BOOLEAN;
    /**
     * Program constructor.
     * - Detects the "bin" name from process argv
     * - Detects the version from package.json
     * - Set up the help command
     * @ignore
     */
    constructor();
    /**
     * @internal
     */
    private setupErrorHandlers;
    /**
     * The program-command is the command attached directly to the program,
     * meaning there is no command-keyword used to trigger it.
     * Mainly used for programs executing only one possible action.
     *
     * @internal
     */
    get progCommand(): Command;
    /**
     * Setup the help command
     */
    private setupHelpCommand;
    /**
     * Customize program help. Can be called multiple times to add more paragraphs and/or sections.
     *
     * @param text Help contents
     * @param options Display options
     */
    help(text: string, options?: Partial<CustomizedHelpOpts>): Program;
    /**
     * Toggle strict mode.
     * Shortcut to calling: `.configure({ strictArgsCount: strict, strictOptions: strict })`.
     * By default, the program is strict, so if you want to disable strict checking,
     * just call `.strict(false)`. This setting can be overridden at the command level.
     *
     * @param strict boolean enabled flag
     */
    strict(strict?: boolean): Program;
    /**
     * Configure some behavioral properties.
     *
     * @param props properties to set/update
     */
    configure(props: Partial<ProgramConfig>): Program;
    /**
     * Get a configuration property value. {@link ProgramConfig Possible keys}.
     *
     * @param key Property
     * @internal
     */
    getConfigProperty<K extends keyof ProgramConfig>(key: K): ProgramConfig[K];
    /**
     * Return a reformatted synopsis string
     *
     * @internal
     */
    getSynopsis(): Promise<string>;
    /**
     * Return the discovery path, if set
     *
     * @internal
     */
    get discoveryPath(): string | undefined;
    /**
     * Return the program version
     *
     * @internal
     */
    getVersion(): string | undefined;
    /**
     * Set the version fo your program.
     * You won't likely use this method as Caporal tries to guess it from your package.json
     */
    version(ver: string): Program;
    /**
     * Set the program name. If not set, the filename minus the extension will be used.
     */
    name(name: string): Program;
    /**
     * Return the program name.
     *
     * @internal
     */
    getName(): string | undefined;
    /**
     * Return the program description.
     *
     * @internal
     */
    getDescription(): string | undefined;
    /**
     * Set the program description displayed in help.
     */
    description(desc: string): Program;
    /**
     * Get the bin name (the name of your executable).
     *
     * @internal
     */
    getBin(): string;
    /**
     * Sets the executable name. By default, it's auto-detected from the filename of your program.
     *
     * @param name Executable name
     * @example
     * ```ts
     * program.bin('myprog')
     * ```
     */
    bin(name: string): Program;
    /**
     * Set a custom logger for your program.
     * Your logger should implement the {@link Logger} interface.
     */
    logger(logger: Logger): Program;
    /**
     * Get the configured logger instance
     */
    getLogger(): Logger;
    /**
     * Disable a global option. Will warn if the global option
     * does not exist of has already been disabled.
     *
     * @param name Name, short, or long notation of the option to disable.
     */
    disableGlobalOption(name: string): Program;
    /**
     * Returns the list of all commands registered
     * - By default, Caporal creates one: the "help" command
     * - When calling argument() or action() on the program instance,
     * Caporal also create what is called the "program command", which
     * is a command directly attach to the program, usually used
     * in mono-command programs.
     * @internal
     */
    getCommands(): Command[];
    /**
     * Add a command to the program.
     *
     * @param name Command name
     * @param description Command description
     * @example
     * ```ts
     * program.command('order', 'Order some food')
     * ```
     */
    command(name: string, description: string, config?: Partial<CommandConfig>): Command;
    /**
     * Check if the program has user-defined commands.
     *
     * @internal
     * @private
     */
    hasCommands(): Promise<boolean>;
    /**
     * @internal
     */
    getAllCommands(): Promise<Command[]>;
    /**
     * Return the log level override, if any is provided using
     * the right environment variable.
     *
     * @internal
     * @private
     */
    getLogLevelOverride(): string | undefined;
    /**
     * Enable or disable auto casting of arguments & options at the program level.
     *
     * @param enabled
     */
    cast(enabled: boolean): Program;
    /**
     * Sets a *unique* action for the *entire* program.
     *
     * @param {Function} action - Action to run
     */
    action(action: Action): Program;
    /**
     * Add an argument to the *unique* command of the program.
     */
    argument(synopsis: string, description: string, options?: CreateArgumentOpts): Command;
    /**
     * Add an option to the *unique* command of the program,
     * or add a global option to the program when `options.global`
     * is set to `true`.
     *
     * @param synopsis Option synopsis like '-f, --force', or '-f, --file \<file\>', or '--with-openssl [path]'
     * @param description Option description
     * @param options Additional parameters
     */
    option(synopsis: string, description: string, options?: CreateOptionProgramOpts): Program;
    /**
     * Discover commands from a specified path.
     *
     * Commands must be organized into files (one command per file) in a file tree like:
     *
     * ```sh
     * └── commands
     *     ├── config
     *     │   ├── set.ts
     *     │   └── unset.ts
     *     ├── create
     *     │   ├── job.ts
     *     │   └── service.ts
     *     ├── create.ts
     *     ├── describe.ts
     *     └── get.ts
     * ```
     *
     * The code above shows a short example of `kubectl` commands and subcommands.
     * In this case, Caporal will generate the following commands:
     *
     * - kubectl get [args...] [options...]
     * - kubectl config set [args...] [options...]
     * - kubectl config unset [args...] [options...]
     * - kubectl create [args...] [options...]
     * - kubectl create job [args...] [options...]
     * - kubectl create service [args...] [options...]
     * - kubectl describe [args...] [options...]
     * - kubectl get [args...] [options...]
     *
     * Notice how the `config` command has a mandatory subcommand associated,
     * hence cannot be called without a subcommand, contrary to the `create` command.
     * This is why there is no `config.ts` in the tree.
     *
     * @param path
     */
    discover(dirPath: string): Program;
    /**
     * Do a full scan of the discovery path to get all existing commands
     * This should only be used to generate the full list of command,
     * as for help rendering
     *
     * @private
     */
    private scanCommands;
    /**
     * Reset all commands
     *
     * @internal
     */
    reset(): Program;
    /**
     * Run the program by parsing command line arguments.
     * Caporal will automatically detect command line arguments from `process.argv` values,
     * but it can be overridden by providing the `argv` parameter. It returns a Promise
     * of the value returned by the *Action* triggered.
     *
     * ::: warning Be careful
     * This method returns a `Promise`. You'll usually ignore the returned promise and call run() like this:
     *
     * ```ts
     * [...]
     * program.action(...)
     * program.run()
     * ```
     *
     * If you do add some `.catch()` handler to it, Caporal won't display any potential errors
     * that the promise could reject, and will let you the responsibility to do it.
     * :::
     *
     * @param argv Command line arguments to parse, default to `process.argv.slice(2)`.
     */
    run(argv?: string[]): Promise<unknown>;
    /**
     * Try to find the executed command from argv
     * If command cannot be found from argv, return the default command if any,
     * then the program-command if any, or finally `undefined`.
     * If argv is empty, and there is no defaultCommand or progCommand
     * use the help command
     *
     * @param argv
     */
    private findCommand;
    /**
     * Run a command, providing parsed data
     *
     * @param result
     * @param cmd
     * @internal
     */
    private _run;
    /**
     * Programmatic usage. Execute input command with given arguments & options
     *
     * Not ideal regarding type casting etc.
     *
     * @param args argv array
     * @param options options object
     * @param ddash double dash array
     * @public
     */
    exec(args: string[], options?: Record<string, ParserTypes>, ddash?: string[]): Promise<unknown>;
}

/**
 * Parse a line
 *
 * @param line Line to be parsed
 * @param options Parser options
 * @internal
 */
declare function parseLine(line: string, options?: Partial<ParserOptions>): ParserResult;
/**
 * Parse command line arguments
 *
 * @param options Parser options
 * @param argv command line arguments array (a.k.a. "argv")
 */
declare function parseArgv(options?: Partial<ParserOptions>, argv?: string[]): ParserResult;

/**
 * Main Caporal module.
 *
 * ## program
 *
 * This represents your program. You don't have to instanciate the {@link Program} class,
 * it's already done for you.
 *
 * **Usage**
 *
 * ```ts
 * // The Program instance generated for you
 * import program from "@caporal/core"
 *
 * program
 *  .command(...)
 *  .action(...)
 * [...]
 * ```
 *
 *
 * ## parseArgv()
 *
 *  This is the command line parser internaly used by Caporal.
 *
 * ::: tip Advanced usage
 * Usually, **you won't need to use the parser** directly, but if you
 * just want to parse some args without all capabilities brought
 * by Caporal, feel free to play with it.
 * :::
 *
 * **Usage**
 *
 * ```ts
 * import { parseArgv } from "@caporal/core"
 *
 * const {args, options} = parseArgv({
 *  // ... options
 * })
 * ```
 *
 * Checkout `parseArgv()` [documentation here](/api/modules/parser.md).
 *
 *
 * ## chalk
 *
 * `chalk` npm module re-export
 *
 * **Usage**
 *
 * ```ts
 * import { program, chalk } from "caporal"
 *
 * program
 *  .command('pay')
 *  .argument('<amount>', 'Amount to pay', Validator.NUMBER)
 *  .action(({logger, args}) => {
 *    logger.info("You paid $%s", chalk.red(args.amount))
 *  })
 * [...]
 * ```
 *
 *
 * @packageDocumentation
 * @module @caporal/core
 */

/**
 * @ignore
 */
declare const program: Program;

export { Action, ActionParameters, Argument, ArgumentSynopsis, ArgumentsRange, BaseConfig, CaporalValidator, Command, CommandConfig, CommandCreator, Configurator, CreateArgumentOpts, CreateCommandParameters, CreateOptionCommandOpts, CreateOptionProgramOpts, ErrorMetadata, FunctionValidator, GlobalOptions, Logger, Option, OptionSynopsis, OptionValueType, ParsedArgument, ParsedArguments, ParsedArgumentsObject, ParsedOption, ParsedOptions, ParserOptions, ParserProcessedResult, ParserResult, ParserTypes, Program, ProgramConfig, Promisable, Validator, ValidatorWrapper, program as default, parseArgv, parseLine, program };
